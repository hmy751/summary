# 데이터 타입
---
데이터 타입은 데이터의 종류를 말하며 크게 **2가지**로 **원시형(primitive)**과 **참조형(reference)**으로 나뉜다.

## 원시형(Primitive Type)
원시형 데이터는 아래와 같이 7가지가 존재하며, 값이 **불변한다는 특징**이 있다.

- number
- string
- undefined
- null
- boolean
- symbol
- bigint

### truthy, falsy
자바스크립트는 **boolean 문맥**에서 **자동으로 형 변환**을 사용한다.
falsy값은 boolean 문맥에서 **false로 평가**되는 값을 말하며 아래와 같이 8가지가 있다.

- false
- 0
- -0
- 0n
- ""
- null
- undefined
- NaN
truthy값은 boolean 문맥에서 **true로 평가**되는 값을 말하며 **falsy값을 제외한 모든 값**을 말한다.

### undefined, null
undefined, null 모두 **값이 없음을 나타내는** 데이터다.
**차이점은** undefined의 경우 개발자가 직접 명시할 수 도 있지만 **자바스크립트 엔진이** 데이터가 없는 경우 **자동적으로 부여**하는 경우가 있다.
null은 자바스크립트 엔진이 **자동적으로 부여할 수 없다.**

따라서 두 경우를 구분하기 위해 데이터가 없음을 직접 명시하려는 경우 null을 사용하는게 낫다.

## 참조형(Reference Type)
참조형 데이터는 객체, 배열, 함수, 정규 표현식등 **모든 객체 데이터**를 의미 하며 데이터가 **가변하는 특징**을 갖는다.

# 변수와 데이터
---
## 변수
프로그램에서 메모리에 저장된 데이터를 이용하기 위해 명시한 식별자를 변수라고 한다. 이 변수의 식별자에는 저장된 **값의 메모리 주소값을 저장하여 참조한다.**

## 변수 선언과 데이터 할당
코드로는 var, let, const 등의 키워드로 식별자 앞에 붙여서 변수를 선언하고, 할당 연산자를 통해 변수에 데이터를 할당하여 저장한다.

실제 프로그래밍에서 변수 선언과 데이터 할당 과정은 변수, 값 **모두 메모리에 저장**하며, 단지 메모리의 **주소값을 통해** 변수에 값을 **연결하여** 할당하게 된다.

### 원시형 데이터의 저장과정
```js
var a = 100;
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c0fc1a43-1127-4384-85d1-5fff37e02f46/fd611130-a232-4f9e-98ae-19ba16fa030c/Untitled.png)

원시형 데이터의 메모리 저장 과정은 **변수와 값의 영역**으로 나누어 **메모리에** 저장한다.

**변수 영역 메모리**에는 해당 메모리의 주소값과 식별자, **값 메모리의 주소값을 저장**하고, 값 영역 메모리에는 해당 메모리의 주소값과 값의 데이터를 저장한다.

변수 메모리에 저장한 **값 메모리의 주소값을 통해 접근**하며 값을 참조한다.

### 참조형 데이터의 저장 과정
```js
var obj = {
	a: 100,
	b: 30,
	...
};
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c0fc1a43-1127-4384-85d1-5fff37e02f46/3b643924-462f-43fd-9718-bc5a9985bbfc/Untitled.png)

원시형 데이터 처럼 변수 영역과 값의 영역으로 나누어 메모리에 저장한다.

차이점은 **프로퍼티 변수를 한 번 더 참조하는 과정**이 있다.

객체 변수에서 값 메모리의 주소값을 통해 접근하면 **해당 프로퍼티 변수들의 메모리 주소값이 저장**되어 있다.

여기서 **한 번 더 프로퍼티 변수들의 메모리에 접근**하고 해당 프로퍼티 변수 메모리에 저장된 값의 메모리 주소값을 통해 접근하여 값을 참조한다.

## 데이터의 불변성과 가변성
데이터의 불변성은 변하지 않음을 의미하는데 이는 **메모리에 한 번 생성된 데이터가 변하지 않기 때문이다.**

**원시형** 데이터는 **불변성이라는** 특징을 가지고 있다. 원시형 데이터의 경우 변수로 복사한 다음 임의 데이터를 변경하게 되면 **새로운 메모리를 참조**하게 되어 **원본과 복사본이 서로 영향을 받지 않게 되어 불변성을 가진다.**
```js
var a = 5;
var b = a;
b = 4;

console.log(a === 5); // true;
```

참조형 데이터는 **가변성이라는 특징**을 갖는다. 참조형 데이터인 객체의 경우 변수로 복사한 다음 임의 데이터의 프로퍼티의 값을 변경하게 되면 **원본과 복사본은 서로 같은 메모리를 참조하고 있는 상태**에서 **프로퍼티를 변경하기 때문에 서로 영향을 받게 된다.**
이는 객체에서 **프로퍼티 변수를 한 번 더 참조하는 과정**이 있기 때문이다. 
```js
var a = { x: 1};
var b = a;
b.x = 2;

console.log(a.x === 1); // false;
```

그래서 정확히는 **객체의 프로퍼티 변수를 변경**할 때 **가변적인 특성**을 갖는다.

### 얕은 복사, 깊은 복사
얕은 복사와 깊은 복사를 하는 이유는 **객체 데이터의 가변성** 때문에 **원본과 복사본이 서로 영향을 주어** 오류를 발생시킬 위험이 있기 때문이다.

얕은 복사는 객체를 복사할 때 **1depth 프로퍼티까지 새로운 메모리를 참조하는 데이터**로 복사하여 **새 객체에 할당**하여 복사하는 방법이다.
깊은 복사는 객체의 **모든 프로퍼티를 새로운 메모리를 참조하는 데이터**로 복사하여 **새 객체에 할당**하여 복사하는 방법이다.

얕은 복사는 1depth까지 데이터는 불변성을 가지지만 **중첩된 참조형 데이터에 대해서는 불변성을 가지지 못한다.**
깊은 복사는 중첩된 참조형 데이터까지 모두 불변성을 가지게 된다.

얕은 복사를 하는 방법으로는 아래 두 가지가 있다.

- 스프레드 연산자
- Object.assign() 메서드

깊은 복사를 하는 방법으로는 아래 네 가지가 있다.

- 재귀적으로 모든 프로퍼티를 조회하여 새로운 데이터를 할당하는 방법
- lodash의 cloneDeep 메서드
- JSON.stringify(), JSON.parse() 메서드의 직렬화 역직렬화
- structuredClone 메서드

### pass by value, pass by reference
pass by value는 **데이터를 복사하여 전달**할 때 **값 자체를 전달한다는 의미**이며, 원시형 데이터가 이에 해당하고 데이터는 불변하는 특징을 가진다.
pass by reference는 **데이터를 복사하여 전달**할 때 값이 아닌 **주소값을 전달한다는 의미**이며, 참조형 데이터가 이에 해당하고 데이터가 가변하는 특징을 가진다.

실제로 **원시형 데이터도 주소값을 전달**하지만 데이터의 불변한다는 특징을 설명하기 위해 pass by value라고 한다.

### 깊은 비교(Deep Compare), 얕은 비교(Shallow Compare)

^5180cc
얕은 비교는 데이터에 저장된 메모리 주소를 직접 비교하는 방식이다.
얕은 비교를 기준으로 원시형 데이터의 경우 **같은 값을** **같은 메모리 장소**에서 참조하기 때문에 두 데이터를 같다고 판별한다. 
참조형 데이터의 경우, **같은 값**의 데이터라도 같은 메모리에서 참조하지 않고 **각각의 다른 메모리장소**에 저장하기 때문에 다르다고 판별한다.
```js
const a = 5;
const b = 5;
console.log(a === b); // true

const c = { x: 1 };
const d = { x: 1 };
console.log(c === d); // false
```

깊은 비교는 데이터에 저장된 메모리 주소가 아닌 값 자체를 비교하는 방식이다.
깊은 비교 에서 원시형 데이터의 경우 얕은 비교와 같은 결과를 가진다.
참조형 데이터의 경우 직접 값 자체를 비교하기 때문에 판별 결과가 달라진다.
방법으로는 JSON.stringify() 메서드, lodash라이브러리의 isEqual() 메서드들의 활용이 있다 
```js
const c = { x: 1 };
const d = { x: 1 };
console.log(JSON.stringify(c) === JSON.stringify(d)); // true
```

## 호이스팅(Hoisting)
호이스팅은 **변수 선언 시점 이전에 변수를 참조하여** 마치 해당 변수가 **끌어올려진 것 처럼 해석**되는 현상을 말한다.
해당 현상이 발생하는 이유는 **코드가 실행되기 전**에 **평가 과정**을 거치고 이 평가 과정에서 **실행 컨텍스트가 식별자 정보를 미리 수집**하기 때문이다.
그래서 선언 시점 즉 실행 전에 미리 수집한 식별자 정보를 통해서 변수를 참조할 수 있게 된다.

여기서 선언한 키워드에 따라 차이가 발생한다.
var의 경우 식별자 정보를 수집하고 동시에 **초기화 과정을 통해** 자바스크립트 엔진이 **undefined값을 할당한다**.
let과 const의 경우 식별자 정보를 수집하지만 **초기화 과정이 생략**되어 해당 변수에 대한 **데이터가 없는 상태로 저장**된다.

따라서 var는 호이스팅 현상으로 **undefined이라는 값으로 참조**할 수 있고, let과 const는 값이 없지만 해당 식별자 정보는 있기 때문에 **해당 식별자에 대한 reference error가** 발생한다.
그래서 흔히 var에서만 호이스팅이 일어난다고 하지만 **let과 const에서도 식별자에 대한 정보를 미리 알고** 있게 된다.

> TDZ(Temporal Dead Zone)
TDZ는 let과 const로 선언한 변수에서 변수 선언 시점 이전에 해당 변수를 참조할 수 없는데 이 구간을 의미한다.
let과 const는 초기화 과정이 생략되어 참조할 수 없고 참조 시 reference error가 발생한다.

## var, let, const
var는 ES5까지 변수 선언에 사용되는 키워드 이고 let, const는 ES6부터 도입된 변수 선언에 사용되는 키워드다.

4가지 측면에서 차이점이 있다.

- 중복 선언
  var로 선언한 변수는 중복 선언이 가능하지만, let과 const로 선언한 변수는 중복 선언이 불가능하다.
  추가로 const는 선언과 동시에 할당을 해야 한다.
- 함수 레벨 스코프, 블록 레벨 스코프
  var는 **함수 레벨** 스코프를 따르며 함수의 코드를 기준으로 스코프가 형성된다. let과 const는 **블록 레벨** 스코프를 따르고 코드 블록을 기준으로 스코프가 형성된다.
- 변수 호이스팅
  var는 호이스팅이 일어나 변수 선언 시점 이전의 코드에서 해당 변수를 **참조할 수 있으며 undefined**의 값을 반환한다.
  let과 const는 실질적으로 호이스팅이 일어나지만 변수 선언 시점 이전의 코드에서 해당 변수를 **참조할 수 없어 reference error**가 발생한다.
- 재할당
  var와 let은 재할당이 가능하며 const는 재할당이 불가능하며 한 번 선언하여 할당하게 되면 변경하지 못하게 된다.

var는 재선언, 변수 호이스팅, 함수 레벨 스코프의 문제 등으로 가독성이 떨어지고 오류를 발생시킬 여지가 많다. 그래서 기본적으로 변수를 선언할 때는 const를 사용하며 재할당이 필요한 경우에는 let을 사용한다.
