# 비동기

## 동기 처리와 비동기 처리

동기 처리는 실행 중인 테스크가 종료할 때까지 다음에 실행될 테스크가 대기하는 방식을 말한다. 비동기 처리 방식은 실행 중인 테스크가 있어도 다음에 실행될 테스크가 바로 실행 되는 방식을 말한다.

동기 방식은 실행 순서가 보장되지만 블로킹이 발생할 수 있고, 비동기 처리 방식은 블로킹은 발생하지 않지만 실행 순서가 보장되지 않는다. ^c6e5a8

자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖고 있어 한 번에 하나의 테스크만 실행할 수 있는 싱글 스레드 환경으로 동작한다.

싱글 스레드 환경은 한 번에 하나의 테스크만 처리하기 때문에 블로킹이 발생한다.

### 비동기를 사용해야 하는 이유?

동기 처리 방식은 블로킹이 발생한다. 따라서 브라우저에서 이벤트 핸들러, HTTP 요청,setTimeout과 같은 동작들이 자연스럽게 실행되려면 비동기 처리방식을 통해서 병렬적으로 처리한는 과정이 필요하다.

## 이벤트 루프와 테스크 큐

싱글 스레드 환경은 하나의 테스크만 처리가 가능하여 블로킹이 발생한다.
하지만 실제 브라우저에는 비동기 처리 방식을 통해 여러 테스크가 동시에 처리된다.

이러한 자바스크립트의 동시성을 지원하는 것이 이벤트 루프다. 이벤트 루프는 콜 스택과 테스크 큐 사이에 존재하며, 두 곳을 계속해서 감시한다.
감시하는 중에 큐에 대기 중인 함수가 있다면 콜 스택이 비어있을 때 콜 스택으로 이동 시켜 비동기 처리를 도와준다.

테스크 큐는 비동기 함수의 콜백 함수 또는 이벤트 핸들러를 일시적으로 보관하는 장소다.

### 이벤트 루프와 비동기 처리과정

```js
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

setTimeout(foo, 0);
bar();
```

브라우저는 멀티 스레드로 동작하며, 브라우저내 자바스크립트 엔진이 싱글 스레드로 동작한다.

# Promise

프로미스란? 비동기 처리 상태와 처리 결과를 관리하는 객체다.
프로미스는 Promise 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행한다.
이때 성공하면 resolve함수를 호출하고, 실패하면 reject함수를 호출한다.
프로미스는 비동기 처리에 대한 상태 pending, fulfilled, rejected 촐 3가지를 갖는다.

## 프로미스가 필요한 이유

- 비동기 함수 동작
  비동기 함수는 비동기 함수의 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없다.
  따라서 처리 결과에대한 후속처리는 비동기 함수 내부에서 수행해야 하는데 이렇게 하면 코드가 중첩되어 복잡도가 증가하는 콜백 지옥 현상이 발생할 수 있다.

- 에러 처리의 한계

```js
try {
  setTimeout(() => {
    throw new Error("error");
  }, 1000);
} catch (err) {
  console.error("error", err);
}
```

에러 처리를 위해 try/catch구문을 사용할 때, setTimeout함수와 같이 일반적인 비동기 함수 형태로 처리한다면 catch구문에 에러가 잡히지 않는다.
에러는 콜 스택에서 caller(호출자)방향으로 전파된다. 즉 이전 실행 컨텍스트 방향으로 전파되는데 setTimeout함수의 콜백 함수는 setTimeout함수의 실행 컨텍스트가 종료된 후 실행 되므로 이전 실행 컨텍스트로 에러가 전파되지 않으면서 catch에서 에러를 감지하지 못한다.

## 마이크로테스크 큐

마이크로테스크 큐는 테스크 큐와는 별도로 프로미스 후속 처리 메서드의 콜백 함수가 저장되는 공간이다.
테스크 큐처럼 비동기 함수를 저장하다 이벤트 루프에 의해 처리 되며 차이점은 마이크로테스크 큐가 테스크 큐보다 우선순위가 높다.
