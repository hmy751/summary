# 브라우저의 동시성
---
자바스크립트는 싱글 스레드 기반의 언어다. 싱글 스레드로 동작하기 때문에 [[Async, Promise#^c6e5a8|블로킹]]이 발생할 수 밖에 없고 자바스크립트 엔진 만으로는 브라우저의 동시성(Concurrency)을 지원할 수 없다.
이를 위해 자바스크립트 뿐만 아니라 브라우저의 여러 스레드와 프로세스를 통해서 동시성을 지원할 수 있다.

## Event Loop(이벤트 루프)
브라우저의 동시성을 위해 자바스크립트 엔진(콜 스택, Heap) 외에 이벤트 루프, Task Queue(테스크 큐), Web API등을 이용하여 브라우저가 지원 하여 처리한다.

- Event Loop - 이벤트 루프는 콜 스택과 테스크 큐 사이에 위치 한다. 
  콜 스택이 비어 있는지 감시하며 비어 있을 경우 테스크 큐에 있는 작업을 콜 스택으로 전달하는 역할을 한다.
- Web API - setTimeout, DOM, Fetch, HTTP 등 브라우저와 상호 작용할 수 있도록 하는 API 이다.
- Task Queue - Web API 콜백 또는 이벤트 핸들러를 추후에 실행될 수 있도록 저장하는 공간이다.

https://www.lydiahallie.com/blog/event-loop

### 이벤트 루프 처리 과정
```js
setTimeout(() => {
  console.log('first');
}, 0);

console.log('second');
```
먼저 setTimeout**함수가 호출**되어 **실행 컨텍스트를 생성**하고 **콜 스택에 쌓인다**.
콜 스택에 담기기 때문에  해당 **함수가 실행**되고 **콜백 함수와 타이머 정보**가 **Web API로** 넘긴다. **해당 컨텍스트는 종료되고** **콜 스택에서 팝** 된다.
콜 스택에서 실행이 종료되어 다음 코드로 넘어가고 console.log호출하고 해당 컨텍스트를 생성하여 콜 스택에 담아 실행 한다.
'second'를 출력하고 해당 컨텍스트는 종료되어 콜 스택에서 팝 된다.
그 동안 **Web API에서** 넘겨 받은 해당 콜백 함수는 **지정된 타이머 시간 이후** **테스크 큐로** 해당 콜백 함수를 **넘긴다.**
**이벤트 루프**가 콜 스택과 테스크 큐를 **감시**하며, **콜 스택이 비어 있게 될 때** **테스크 큐의** 콜백 함수를 **콜 스택으로 넘긴다.**
콜 스택에 콜백 함수가 넘어오게 되고 실행되어 'first'를 출력하며 종료된다.

## 마이크로 테스크 큐와 프로미스

^c84bba

마이크로 테스크 큐는 **프로미스 콜백**을 저장하며 추후에 실행될 수 있도록 저장하는 공간이다. **우선순위**는 **테스크 큐보다 더 높아** 먼저 실행된다.

```js
setTimeout(() => {
	console.log(1)
}, 0);

Promise.resolve()
	.then(() => console.log(2))
	.then(() => console.log(3));
```
setTimeout함수와 Promise가 같이 실행될 때
먼저 setTimeout함수가 호출되어 해당 컨텍스트가 콜 스택에 담겨 실행되고 콜백 함수와 타이머 정보가 Web API에 넘겨진다.
setTimeout함수의 실행 컨텍스트는 종료되고 Promise가 호출된다.
Promise의 실행 컨텍스트가 콜 스택에 담기고 실행된다.
Promise는 실행되어 프로미스 객체를 생성하고 바로 resolve되며 종료된다. 해당 프로미스의 then함수가 다시 실행 컨텍스트를 생성하며 콜 스택에 담기고 실행 되며 해당 콜백 함수를 마이크로테스크 큐에 넘기며 해당 컨텍스트는 종료된다.
이제 테스크 큐와 마이크로테스크 큐에 콜백함수들이 대기하고 이벤트 루프는 콜 스택이 비어있는지 감시한다.
모든 함수가 종료되어 콜 스택이 비어 있으므로 테스크들을 넘기는데 마이크로테스크 큐가 우선순위가 높으므로 해당 테스크들을 모두 콜 스택에 넘긴다.
모두 종료되면 그 뒤에 테스크 큐에 있는 콜백 함수를 넘겨 실행하며 종료된다.

- fetch함수 처리
```js
fetch('https://api...')
  .then((res) => console.log(res));

console.log('end');
```
fetch가 호출 되면 해당 실행 컨텍스트가 생성되고 콜 스택에 담겨 실행된다.
실행 되면 fetch는 Web API로서 프로미스 오브젝트를 생성하고 해당 프로미스 오브젝트는 pending상태와 undefined결과를 가지고 then 콜백 함수가 해당 프로미스 오브젝트의 PromiseReaction에 넘겨지며 해당 컨텍스트는 종료되며 콜 스택에서 팝 된다.
fetch가 외부에 요청하는 동안 console.log('end')가 호출되고 실행되어 end를 출력한다.
요청이 완료되면 해당 프로미스의 오브젝트는 'fullfilled'상태로 되고 해당 결과는 response에 담긴다.
fullfilled상태가 되면 바로 PromiseReations에 저장한 콜백 함수를 마이크로테스크 큐에 넘긴다.
이벤트 루프가 콜 스택이 비어있는 것을 확인하면 해당 콜백 함수를 콜 스택으로 넘기며 실행 된다.
해당 콜백 함수에서 response를 출력하며 종료된다.

```js
console.log("start"); 

setTimeout(() => { 
  console.log("macrotask 1"); 
},  0); 

Promise.resolve() 
  .then(() => { 
    console.log("microtask 1"); 
    }) 
  .then(() => { 
    console.log("microtask 2"); 
  }); 

requestAnimationFrame(() => { console.log("requestAnimationFrame callback"); }); 

console.log("end");

```

## requestAnimationFrame(rAF)
rAF(requestAnimationFrame)는 브라우저 프레임 속도에 맞추어 리페인트 전 단계에서 애니메이션을 호출할 수 있도록 브라우저에 요청하는 함수이다.

대게 화면의 주사율은 60fps이며 1초에 60번 그려진다.
이를 고려해 애니메이션이 화면에 자연스럽게 그려지려면 브라우저의 한 프레임이 1000 / 60 ms 안에 완료돼야 한다. 
rAF가 그에 맞춰질 수 있도록 브라우저에 요청하며 애니메이션 함수가 리페인트 전단계에 호출될 수 있도록 한다.

### 특징
#### 프레임을 고려한 실행
일반적인 타이머 함수로 애니메이션을 호출하게 되면 브라우저 로딩 과정중에 콜 스택에서 실행하게 되고 다시 리플로우가 발생하게 된다. rAF를 사용하게 되면 프레임을 고려하여 리페인트 단계에서 실행하게 하여 프레임이 지연되는 문제가 해결된다.

#### 백그라운드 동작 중지
일반적인 타이머 함수를 실행하게 되면 브라우저가 다른 탭을 보거나 비활성화 될때에도 실행되어 리소스가 낭비 되는데 rAF는 실행이 중지되어 리소스를 낭비하지 않게 된다.

#### 주사율에 맞게 호출
무조건 1초에 60번 호출하지 않고 디스플레이의 주사율에 맞게 호출한다. 예를들어 144hz이면 1초에 144번 호출할 수 있도록 최적화 하여 호출하게 한다.

## Animation Frames
rAF의 콜백 함수는  테스크 큐나 마이로테스크 큐가 아닌 Animation frames에 댬겨서 처리 된다.

### 사용법
인자로 실행할 콜백 함수를 받으며 재귀 형태로 호출하여 애니메이션을 실행 한다.
```js
const animation = () => {
	...
	
	requestAnimationFrame(animation);
};

requestAnimationFrame(animation);
```
