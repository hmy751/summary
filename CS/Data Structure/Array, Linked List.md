선형 리스트(linear list)는 어떤 순서에 의해 나열된 데이터가 여러 개인 구조를 말한다. 그리고 선형 리스트를 구현하는 방법에는 배열(array)과 연결 리스트(linked list)가 있다.

## Array

---

배열(array)은 데이터를 순서대로 나열한 구조로, 첫 번째 데이터로부터 떨어진 상대적인 위치로 나머지 데이터를 참조한다.  
인덱스(index)로 해당 데이터에 접근할 수 있으며, 해당 인덱스를 알면 시간 복잡도는 O(1)가 된다.

### 데이터 삽입, 삭제

배열에서는 데이터를 삽입, 삭제 과정에서 해당 데이터의 공간을 위해 조정하는 작업이 필요하다.

데이터를 삽입할 경우 맨 뒤에 데이터를 삽입하는 경우는 빈 공간을 만들어 데이터를 삽입하면 되고 시간 복잡도는 O(1)이 된다. 이 경우를 제외하고는 해당 데이터가 들어갈 공간을 만들기 위해 해당 공간 뒤에 데이터를 뒤로 이동시키는 과정이 필요하며, 이 때 뒤로 이동한 데이터 만큼이며 시간 복잡도는 O(N)이다.

데이터를 삭제하는 경우 맨 뒤에 데이터를 삭제하는 경우는 시간 복잡도가 O(1)이 된다. 이 경우를 제외하고는 해당 데이터를 삭제하고 빈 공간을 채우기 위해 뒤에 데이터를 앞으로 이동하는 과정이 필요하며, 이때 데이터 이동 만큼이며 시간 복잡도는 O(N)이 된다.

배열에서 삽입과 삭제 동작에는 데이터를 옮기는 시간이 필요하다.

## Linked List

---

연결 리스트(linked list)는 각 데이터들을 노드형태로 저장하여 포인터로 연결하여 관리하는 구조다. 각 노드는 데이터 영역, 포인터 영역으로 구성되며 데이터 영역은 데이터 값을 포인터 영역은 다음에 연결될 데이터를 가리킨다.

연결 리스트에서 제일 첫 번째 노드를 Head라고 한다. 이 Head에서 시작하여 데이터들이 연결되며 가장 끝단에 노드를 Tail이라고 한다. 그리고 가장 끝, Tail의 포인터 영역은 Null을 가리키며 리스트가 구성된다.

### Singly Linked List

단순 연결 리스트(singly linked list)는 노드에 포인터 영역이 하나인 연결 리스트로 가장 많이 사용되는 기본적인 연결 리스트 형태이다.

#### 데이터의 탐색, 삽입, 삭제 및 시간 복잡도

배열과 달리 연결 리스트의 검색은 정해진 인덱스에 데이터가 있지 않고 포이터로 연결되어 있기 때문에 시간 복잡도는 O(N)이다.
데이터를 삽입하는 경우 끝에 생성한 노드의 연결만 바꾸면 되기 때문에 시간 복잡도는 O(1)이며,
데이터를 삭제하는 경우에는 끝에 있는 노드전의 노드의 위치가 필요하고, 찾은 다음에는 해당 노드의 연결만 바꾸면 되기 때문에 시간 복잡도는 O(N)이 된다.

#### [구현코드](https://github.com/hmy75d/data-structure-code/blob/main/src/dataStructure/singlyLinkedList.ts)

### Doubly Linked List

이중 연결 리스트는 단순 연결 리스트와 구조는 비슷하지만, 각 리스트의 노드가 다음 노드뿐만 아니라 이전 노드도 가리키는 연결 리스트다.

#### 데이터의 탐색, 삽입, 삭제 및 시간 복잡도

이중 연결 리스트는 탐색의 경우 포인터를 따라서 노드를 찾아가기 때문에 시간 복잡도는 O(N)이 된다.
데이터를 삽입하는 경우 맨 뒤에 있는 노드에 새로운 노드를 추가하기 때문에 시간 복잡도는 O(1)이 된다.
데이터를 삭제하는 경우 맨 뒤에 있는 노드가 이전 노드를 가리키고 있기 때문에 바로 연결만 바꿔주면 돼며 시간 복잡도는 O(1)이 된다.

#### [구현코드](https://github.com/hmy75d/data-structure-code/blob/main/src/dataStructure/doublyLinkedList.ts)
