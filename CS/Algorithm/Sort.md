# Bubble Sort
---
버블 정렬은 서로 인접한 두 원소를 모두 비교하여 정렬하는 방식이다. 가장 기본적이고 간단한 정렬 알고리즘으로 시간 복잡도가 커서 거의 사용하지는 않는다.
in-plce 알고리즘 방법중 하나로 추가 메모리를 사용하지는 않는다.

시간 복잡도 - O(N2), O(N) 모두 정렬되어 있을 경우
공간 복잡도 - O(1)

https://github.com/hmy75d/data-structure-code/blob/main/src/Algorithm/bubbleSort.ts

# Selection Sort
---
선택 정렬은 첫 번째 위치부터 최소값이 있을 자리를 선택하고, 그 이후의 원소들을 차례대로 조회하며 선택한 자리에 최소값이 올수 있도록 지정하며 정렬해 나가는 방식이다.
in-place 알고리즘 방법중 하나로 추가 메모리를 사용하지 않는다.

시간 복잡도 - O(N2)
공간 복잡도 - O(1)

https://github.com/hmy75d/data-structure-code/blob/main/src/Algorithm/selectionSort.ts

# Insertion Sort
---
삽입 정렬은 왼쪽에 정렬한 배열을 두고, 그 이후의 원소들을 차례대로 조회해 나가며 정렬한 배열의 삽입될 위치를 찾아 삽입해 나가며 정렬을 하는 방식이다.
대부분의 요소들이 이미 정렬되어 있는 경우에 효율적일 수 있다. 하지만 비교적 많은 요소들의 이동을 포함할 수 있다.

시간 복잡도 - O(N) 최선일 경우, 이외는 O(N2)
공간 복잡도 - O(1)

https://github.com/hmy75d/data-structure-code/blob/main/src/Algorithm/insertionSort.ts

# Merge Sort
---
병합 정렬은 분할 정복(Divide and Conquer)기법을 사용한다.
병합 정렬은 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 리스트를 정렬한 다음, 두 개의 정렬된 리스트를 다시 합하여 전체가 정렬되게 하는 방법이다.

in-place알고리즘이 아니며 병합할 새로운 배열이 필요하다. 또 요소들이 많으면 이동 횟수가 많아 시간적 낭비가 크다.

## 시간 복잡도
병합 정렬의 시간 복잡도는 분할 단계와 병합 단계가 각각 있고 이를 더해 최종 시간 복잡도가 구해진다. 
먼저 분할 단계는 n개의 요소의 배열을 계속해서 1이 될 때까지 나누는 작업에서 시간 복잡도 O(logN)이 있다. 
병합 단계는 n개의 요소들을 조회하며 정렬하는 구간에서 O(N)의 시간 복잡도와, 그 요소들을 병합하는 과정 O(logN)이 있어 병합 단계의 시간 복잡도는 O(NlogN)가 된다.
그래서 최종적으로는 모두 더하면 O(NlogN)의 시간 복잡도를 가지게 된다.

데이터의 분포의 영향없이 시간 복잡도가 O(NlogN)으로동일하다.

시간 복잡도 - O(NlogN)
공간 복잡도 - O(N)

https://github.com/hmy75d/data-structure-code/blob/main/src/Algorithm/mergeSort.ts

# Quick Sort
---
퀵 정렬은 병합 정렬과 마찬가지로 분할 정복 기법을 사용한다.
기준점인 피벗(Pivot)을 선택하고 피벗을 기준으로 작은 요소들을 왼쪽으로, 큰 요소들을 오른쪽으로 재 배치한다. 이 분할된 하위 배열들을 다시 퀵 정렬을 수행하며 각 배열들이 크기가 1이하가 될때 까지 재귀적으로 수행한다.

## 특징
장점은 속도가 빠르고 추가 메모리 공간을 필요로 하지 않는다.
단점은 이미 정렬된 데이터에 대해서 퀵 정렬의 불균형 분할로 오히려 시간이 더 많이 걸릴수 있다.

## 시간 복잡도
시간 복잡도 최악의 경우는 피벗이 배열의 최소값이나 최대값을 반복적으로 선택하여 배열이 불균형하게 나누어지는 경우이다. 이때 재귀 호출의 깊이는 N에 가까워지고, 각 호출에서 배열의 모든 요소N의 시간을 고려하면 시간복잡도가 O(N2)이 된다.
이외 최선 및 평균적으로는 배열이 매번 절반에 가깝게 나누어진다고 가정하면 재귀 호출의 깊이는 logN이고 각 호출에서 배열의 모든 요소N의 시간을 고려하면 전체 시간 복잡도는 O(NlogN)으로 된다.

공간 복잡도는 최악의 경우 in-place로 교환할 경우 메모리는 추가하지 않지만 재귀 호출을 하고 N의 깊이 만큼 호출하여 O(N)이된다.
이외 최선 및 평균적으로는 O(logN)이 된다.

시간 복잡도 - O(NlogN) 평균, O(N2) 최악의 경우
공간 복잡도 - O(logN) 평균, O(N) 최악의 경우

https://github.com/hmy75d/data-structure-code/blob/main/src/Algorithm/quickSort.ts