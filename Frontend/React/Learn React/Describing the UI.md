React 앱은 컴포넌트라고 불리는 독립된 UI로 이루어진다. React 컼포넌트는 마크업을 얹을 수 있는 자바스크립트 함수다.

# 첫번째 컴포넌트
---
## 컴포넌트: UI 구성 요소

리액트에서 컴포넌트는 마크업, CSS, JS를 결합하여 앱의 재사용 가능한 UI요소로 개발자가 정의하여 만든 것이다.
React 앱에서 모든 UI는 컴포넌트이다.

## 컴포넌트 정의하기
컴포넌트는 마크업으로 뿌릴 수 있는 자바스크립트 함수다.
자바스크립트 함수이기 때문에 export default 접두사로 파일을 보낼 수 있고 또 import할 수 잇다.
함수로 정의하며 함수명은 반드시 대문자로 표기해야 한다.
마크업을 추가할 수 있고 이는 HTML 처럼 작성되어 잇지만 실제로는 자바스크립트이고 이를 JSX라고 한다.

## 컴포넌트 사용

대소문자에 따라 소문자는 HTML태그로 인식하고, 대문자는 리액트 컴포넌트를 사용하는걸로 이해한다.

### 컴포넌트 중첩 및 구성

컴포넌트는 복잡해지면 import, export를 이용해서 분리할 수 있고 분리하여 정의한 컴포넌트는 하위 컴포넌트로 사용할 수 있다. 하지만 부모 컴포넌트 내부에서 중첩하여 정의하는 것은 되지 않는다. 이유는 리렌더링 발생시 중첩하여 정의된 컴포넌트가 생성하면 매우 느리게 되며 버그를 발생시킬 수 있다.

# 컴포넌트 import, export
---
컴포넌트는 파일을 분리하여 재사용할수 있으며 조합하여 다른 컴포넌트도 만들 수 있다. 이렇게 분리하면 재사용하기 쉽고 파일을 찾기 쉬워진다.

## Root 컴포넌트
리액트는 기본적으로 App.js에 root컴포넌트 파일에 모든 컴포넌트가 존재하며 Next js의 경우 페이지별로 root 컴포넌트가 다르다.

# JSX로 마크업 작성하기
---
JSX는 자바스크립트를 확장한 문법으로, 자바스크립트 파일을 HTML과 비슷하게 마크업을 작성할 수 있도록 해준다.

## JSX, 자바스크립트에 마크업 넣기

리액트에서는 기존에 따로 분리하던 HTML, CSS, Javascirpt파일을 하나로 관리하도록 컴포넌트에 정의하였다. 현재는 웹이 인터랙티브 해지면서 로직자체가 내용을 결정하는 경우가 많아졌기 때문이다.
그래서 렌더링 로직과 마크업이 컴포넌트라는 같은 위치에 있게 되었다.

마크업과 렌더링 로직이 같이 있어 변화가 생겨도 서로 동기화 상태를 잘 유지할 수 있다.

또 리액트 컴포넌트는 브라우저에 마크업을 렌더링할 수 있는 자바스크립트 함수이다. JSX라는 확장된 문법을 사용하여 마크업을 나타낸다. JSX는 HTML과 비슷해 보이지만 조금 더 엄격하며, 동적으로 정보를 표시할 수 있다.

## JSX의 규칙

### 1. 하나의 루트 엘리먼트로 반환해야 한다.

한 컴포넌트에서 여러 엘리먼트를 반환하려면 하나의 부모 태그로 감싸야 하며, 부모 태그를 추가하고 싶지 않다면 Fragment라도 추가하여 하나의 부모 태그로 감싸서 반환해야 한다.

JSX는 HTML이 아니라 자바스크립트 객체로 변환된다. 하나의 배열로 감싸지 않은 하나의 함수에서는 두 개의 객체를 반환할 수 없어 두 개의 JSX태그를 반환할 수 없다.

### 2. 모든 태그는 닫아주기

이미지 태그도 `<img />` 이렇게 셀프로 닫아주어야 한다.

### 3. 카멜 케이스로

JSX는 자바스크립트로 바뀐다. 따라서 JSX에서 작성된 어트리뷰트는 자바스크립트 객체의 키가 된다. 
대시나 예약어는 자바스크립트 변수명에 제한이 있기 때문이다.

~~# 중괄호가 있는 JSX 안에서 자바스크립트 사용하기~~
---
자바스크립트 로직을 마크업 내부에 위치하여 동적인 프로퍼티를 참조하고 싶을때 JSX에서 중괄호를 사용하여 자바스크립트를 사용할 수 있다.

## 따옴표로 문자열 전달하기

어트리뷰트에 따옴표를 통해서 문자열을 사용할 수 있으며 동적인 변수는 중괄호를 통해 사용할 수 있다.

## 중괄호 사용

자바스크립트 표현식은 중괄호 사이에서 작동한다.

## 이중 중괄호

JSX에는 문자열, 숫자 및 기타 자바스크립트 표현식뿐만 아니라 객체를 전달할 수 도 있다. 객체를 전달하려면 이중 중괄호를 통해 전달할 수 있다.

## 자바스크립트 객체와 중괄호

JSX는 자바스크립트를 사용하여 데이터와 논리 구성이 가능한 탬플릿 언어다.

# 컴포넌트에 props 전달하기
---
리액트 컴포넌트는 props를 통해서 서로 통신한다. porps는 객체, 배열, 함수를 포함한 모든 자바스크립트 값을 전달할 수 있다.

## Props의 변경

props는 변경하지 말아야 하며 사용자 입력에 반응해야 하는 경우는 setstate를 사용이 필요하다.

# 조건부 렌더링
---
if, &&, ? : 연산자를 통해서 조건부로 JSX를 렌더링할 수 있다.

## 조건부로 JSX 반환하기

```jsx
if (isPacked) {  
	return <li className="item">{name}✔</li>;
	}return <li className="item">{name}</li>;
```

```jsx
return (  <li className="item">    {isPacked ? name + ' ✔' : name}  </li>);
```
위와 같이 조건문 또는 삼항 연산자로 표현할 수 있는데 객체 지향 프로그래밍에서는 두 가지 다른 인스턴스를 만들어 다르다고 볼 수 있지만, JSX 엘리먼트는 내부 상태를 보유하지 않고 실제 DOM노드가 아니기 때문에 인스턴스가 아니다.
따라서 두 예시는 똑같이 동작한다.

## && 연산자
주의할점은 && 연사자 왼쪽에 0을 두면 &&연산자는 판별 후에 원래의 값을 반환한다. 따라서 0의 값을 두고 사용하게 되면 0이 렌더링이 된다.

# 리스트 렌더링
---
배열 메서드를 사용하여 데이터 배열을 필터링하고 조작하여 컴포넌트 배열로 변환할 수 있다.

## 배열 항목에 key사용
배열 항목에는 key를 사용해야 한다. 여기서 key는 각 컴포넌트가 어떤 배열항목에 해당하는지 React에 알려주는 역할을 하며 나중에 일치시킬 수 있도록한다.

key의 목적에 맞게 key는 변경되어서는 안되고, 형제 간에 고유해야 한다.

key를 명시해야 하는 이유는 리스트에서 삭제나 삽입등으로 변경될 때 재 정렬이 일어나며, 이때 위치가 변경되더라도 생애 주기내key를 통해 특정 항목을 식별할수 있게 되며 이를 통해 무슨일이 일어나는지 정확히 추론할 수 있으며 DOM트리를 올바르고 효율적으로 업데이트할 수 있다.

# 컴포넌트 순수하게 유지하기
---
순수 함수는 같은 입력에 대해 같은 출력을 반환해야 하며 호출전에 있던 객체나 변수에는 영향을 주지 않아야 한다.

## 순수 컴포넌트

리액트에서도 모든 컴포넌트가 순수 함수를 가정하고 작성되어야 한다. 즉 같은 입력이 주어지면 반드시 같은 JSX를 반환해야 한다.

## 사이드 이펙트(의도하지 않은 결과)

순수하지 않는 경우는 컴포넌트가 외부의 변수를 참조해 변경하는 경우로 이때는 컴포넌트가 여러개 생성될때마다 의도하지 않게 작동한다. 이를 방지하기 위해서는 프로퍼티로 변수를 넘겨서 개선할 수 있다.

<React.StrictMode>로 감싸서 엄격 모드를 활용해 순수성을 해치는 연산을 감지할 수 있다. 리액트에서 세가지 종류의 입력 요소 props, state, context가 있는데 항상 읽기 전용으로 취급해야 하며, 만약 변경하려는 경우 set state를 이용해서 변경해야 한다.

### Local Mutation(지역 변형)

렌더링 하는동안 컴포넌트가 기존 변수 즉 외부의 데이터를 변경하는 것은 순수 함수성을 해치는 것으로 문제가 된다. 하지만 렌더링하는 동안 만든 변수와 객체를 변경하는 것, 즉 컴포넌트 함수 내부의 변수를 변경하는 것은 문제가 되지 않는다. 이를 local mutation이라고 한다.

## 사이드 이펙트를 일으킬 수 있는 곳

순수성을 유지하더라도 변경 자체는 불가피 하다. 렌더링 중에 일어나는 것이 아니라 부수적으로 일어나는 화면 업데이느, 애니메이션, 데이터 변경과 같은 변경을 사이드 이펙트라고 한다.

보통 사이드 이펙트는 이벤트 핸들러가 있다. 이벤트 핸들러는 컴포넌트 내부에 정의 되어 있지만 렌더링 중에는 실행되지 않는다. 따라서 이벤트 핸들러는 순수할 필요가 없다.

그리고 최후의 수단으로 사이드 이펙트에 적합한 이벤트 핸들러가 없다면 useEffect호출을 통해 변경할 수 있다.

## 순수성을 유지해야 하는 이유

먼저 동일한 입력에 대해 같은 출력을 반환하기 때문에 
다른 환경, 서버에서 실행할 수 있고 캐싱을 위해서 변경되지 않은 컴포넌트에 대해 렌더링을 건너 뛸수 잇다. 그리고 렌더링 중간에 변경되더라도 순수성 덕분에 계산을 중단해도 안전하다.

# UI를 트리로 이해하기
---
리액트는 많은 컴포넌트들이 서로 중첩된 형태로 구성되어 있다. 컴포넌트의 구조를 추적하기 위해 UI를 트리로 모델링 한다.

## 트리로 보는 UI

브라우저와 모바일과 마찬가지로 리액트 역시 트리 구조를 사용하여 컴포넌트의 관계를 관리하고 모델링 한다.
이 트리를 통해 리액트앱의 데이터가 어떻게 흘러가는지, 렌더링 및 앱의 크기를 최적화 하는 방법을 이해할 수 있는 도구로 사용된다.

## 렌더 트리

컴포넌트의 특징은 다른 컴포넌트와 합성할수 있다. 컴포넌트를 중첩하면 부모, 자식 컴포넌트의 개념이 생기며, 각 부모 컴포넌트는 또 다른 자식이 될 수 있다.

트리는 노드들로 구성되며 각 노드는 컴포넌트를 나타낸다.
리액트 렌더트리의 루트 노드는 앱의 루트 컴포넌트다. 루트 컴포넌트는 App이며 리액트가 렌더링하는  첫 번째 컴포넌트다.

리액트의 렌더트리는 HTML태그가 기준이 아니라 컴포넌트로 구성되어 있다.

렌더 트리는 트리 구조로 루트 컴포넌트 부터 리프 컴포넌트까지 식별할 수 있으며 최상위 컴포넌트에 따라 하위 의 컴포넌트 들에 렌더링 성능에 영향을 미친다. 또 리프 컴포넌트는 하위에 있기 때문에 자주 리렌더링 된다.

## 모듈 의존성 트리

리액트에서는 컴포넌트 뿐만 아니라 모듈의 종속성도 트리로 모델링 한다. 컴포넌트나 로직 별도의 파일로 분할 하면서 JS모듈을 만들어 낸다.

import를 통해서 파일의 종속성에 관한 트리를 나타낸다.

루트 노드는 entrypoint파일이라고 하여 루트 모듈로 본다.

트리를 구성하는 노드는 컴포넌트가 아니라 모듈을 나타낸다.

종속성 트리는 리액트에 모듈들을 결정하는데 사용된다. 프로덕션용으로 앱을 빌드할 때 자바스크립트를 번들로 묶는 빌드단계 가 있다. 이를 담당하는 도구를 번들러라고 하며, 번들러는 종속성 트리를 사용하여 어떤 모듈을 포함할지 결정한다.

앱의 번들이 커짐에 따라 실행하는데 비용이 많이 들며 UI가 그려지는 시간이 지연될 수 있다. 이때 종속성 트리을 이해하면 디버깅하는데 도움이 된다.