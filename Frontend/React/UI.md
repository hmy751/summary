# Component
---
컴포넌트(Component)는 HTML 마크업, CSS, JS파일을 결합하여 앱의 재사용 가능한 UI요소로 개발자가 정의하여 만든 단위이다.
리액트 앱에서 모든 UI는 컴포넌트로 구성된다.

## 컴포넌트 정의하기

컴포넌트는 마크업으로 뿌릴 수 있는 자바스크립트 함수다. 자바스크립트 함수 이며 대문자로 표기하여 함수명을 정의해야 한다.
또 HTML처럼 작성되어 있지만 실제로는 자바스크립트이고 이를 JSX라고 한다.
 따라서 컴포넌트는 JSX를 반환하여 정의한다.

## 컴포넌트 중첩 및 구성

컴포넌트는 복잡해지면 import, export를 이용해서 분리할 수 있고 부모, 하위 컴포넌트 관계로 중첩하여 사용할 수 있다. 
다만 부모 컴포넌트 내부에서 하위 컴포넌트를 정의하면 안되는데 이유는 리렌더링 발생 시 정의된 컴포넌트가 생성되며 매우 느리게 되기 때문이다.

리액트는 기본적으로 App.js 파일에 Root 컴포넌트가 있으며 이 컴포넌트에 모든 컴포넌트가 존재하도록 구성되어 있다.
Next.js의 경우에는 페이지별로 Root 컴포넌트가 다르게 구성되어 있다.

## 컴포넌트에 props 전달하기

컴포넌트는 props를 통해서 서로 통신할 수 있고 모든 자바스크립트 값을 전달할수 있다.
props는 변경하는 값이 아니며, 입력에 반응해야 하는 경우는 setState를 사용해야 한다.

## 컴포넌트의 순수성

프로그래밍에서 순수 함수는 같은 입력이 주어질 때 같은 결과를 반환한다.
리액트에서도 모든 컴포넌트가 순수 함수일거라 가정하고 설계되어 있다. 따라서 모든 컴포넌트는 순수성을 가져야하며, 즉 순수 컴포넌트로 구현되어야 한다.
순수 컴포넌트는 같은 입력에 대해 반드시 같은 JSX를 반환한다.

### 순수성을 유지해야 하는이유

리액트는 순수 함수라는 것을 가정으로 설계되는 것이 이유이다. 
또 중요한 이뉴는 컴포넌트가 순수해야 다른 환경, 서버에서의 실행 캐싱등에 의해 렌더링을 건너 뛰거나 렌더링 중간에 변경되더라도 순수성 덕분에 렌더링 계산을 중단해도 안전하고 예측이 되기 때문이다.

### 사이드 이펙트

컴포넌트가 순수하더라도 데이터, 애니메이션 등 외부에 요소에 의해 바뀌어야 한다. 
즉 렌더링중에 발생이 아니라 사이드에서 발생하는 것을 말하며 이를 통해 데이터를 변경하는 것을 사이드 이펙트라고 한다.

이벤트핸들러도 사이드 이펙트에 포함된다.
이벤트 핸들러는 컴포넌트 내부에서 정의 되지만, 렌더링 중에 실행되지 않고 유저의 입력이 있을때 실행이 된다. 그래서 이벤트 핸들러는 순수 함수일 필요가 없다.

사이드 이펙트가 필요하다면 useEffect호출을 통해 구현할 수 있다.

### Local Mutation(지역 변형)

쉽게 말해서 컴포넌트 내부에서 변수가 렌더링 하는동안 변경되는 것을 말한다.
이는 렌더링 동안에 변형되어도 상관이 없다 왜냐하면 컴포넌트 내부 스코프에서 일어나므로 외부 데이터의 변경을 유발하지는 않기 때문이다.



# JSX
---
JSX는 자바스크립트를 확장한 문법으로 자바스크립트 파일을 HTML과 비슷하게 마크업을 작성할 수 있도록 해준다.

그리고 JSX는 HTML이 아니라 자바스크립트 문법으로 직접 브라우저에서 활용이 되지 않는다. 단지 형태만 HTML을 작성하는 것 처럼 보인다. 
직접 활용되려면 트랜스파일에 의해 변환되어야 하며 변환 결과는 React.createElement의 함수로 반환된다.
```jsx
const element = <h1>Hello world</h1>;

...

const element = React.createElement('h1', null, 'Hello world');
```

React.createElement는 리액트 엘리먼트를 생성하는 함수로 JSX가 컴파일될 때 호출된다.
반환값은 리액트 엘리먼트로 자바스크립트 객체이다.

https://ko.react.dev/reference/react/createElement
## JSX의 규칙

- 하나의 루트 엘리먼트로 반환해야 한다.
	JSX는 HTML이 아니라 자바스크립트 객체로 변환된다. 따라서 하나의 배열로 감싸지 않은 상태, 두 개의 객체로 반환할 수 없어 하나의 부모태그나 Fragment로 감싸야 한다.
- 모든 태그는 셀프로라도 닫아주어야 한다.
- JSX는 자바스크립트로 변환된다. JSX에서 작성된 어트리뷰트는 자바스크립트 객체의 키가 된다.

## 조건부 렌더링

JSX엘리먼트는 객체 지향프로그래밍의 인스턴스와 달리 내부 상태를 보유하지 않아 조건문을 통해서 반환하여도 된다.

```jsx
if (isPacked) {  
	return <li className="item">{name}✔</li>;
	}return <li className="item">{name}</li>;
```

```jsx
return (  <li className="item">    {isPacked ? name + ' ✔' : name}  </li>);
```

## 리스트 렌더링

배열 메서드를 사용하여 데이터 배열을 필터링하고 조작하여 컴포넌트를 배열로 변환할 수 있다.

### 배열 항목에 key 사용하기
리스트로 렌더링 시 배열항목에 key를 사용해야한다. 여기서 key는 컴포넌트가 배열에서 어떤 항목에 해당하는지 React에 알려주는 역할을 한다. 그래서 형제간에 고유한 값을 가져야한다.

또 key를 명시해야 하는 이유는 리스트 내에서 삽입이나 삭제등으로 변경등으로 위치변경에 영향을 주게되면 생애주기내 key를 통해서 항목을 식별할 수 있다. 이를 통해 요소들을 정확히 추론하여 DOM트리를 올바르고 효율적으로 업데이트 할 수 있게된다.

# UI
---
리액트는 컴포넌트의 구조를 UI트리로 모델링 한다.

컴포넌트의 특징은 다른 컴포넌트와 합성할 수 있다. 그래서 컴포넌트를 부모와 자식 구조로 중첩할 수 있다.

리액트도 렌더트리를 구성하는데 HTML태그가 기준이 아니라 컴포넌트로 구성되어 있다.
리액트의 렌더 트리의 루트 노드는 앱의 루트 컴포넌트로 App파일이며 리액트가 렌더링한는 첫 번째 컴포넌트다.
그리고 최상위 보다 리프 컴포넌트가 자주 리렌더링된다.