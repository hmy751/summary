
# 브라우저의 구조
---
- User Interface - 유저와 상호작용하는 부분을 말한다. 주소 표시줄, 주소창, 뒤로/앞으로 가기 버튼 등이 있으며 개인화가 가능하게 설계되어 있다.
- Browser Engine - 서버와 사용자 상호 작용에서 가져온 웹 콘텐츠를 조정하는 역할을 하며, UI와 렌더링 엔진 사이의 동작을 제어한다.
- Rendering Engine - 요청한 웹 콘텐츠를 해석하고 표시한다. 대부분의 브라우저에서는 브라우저 엔진과 렌더링 엔진이 함께 작동하여 콘텐츠를 보여준다.
- Networking - HTTP 요청과 같이 통신 부분을 처리한다.
- UI Backend - 콤보 박스와 창 같은 기본적인 장치를 그린다. OS에서 이미 자체적으로 가지고 있는 UI들이다.
- Javascript Interpreter - 웹 컨텐츠를 조작하고 웹 페이지에 동적 동작을 가능하게 해주는 요소다.
- Data Storage - 브라우저 동작에 필요한 자료를 저장하는 계층이다.

# 브라우저 렌더링 과정
---
웹 페이지에 필요한 리소스를 받고 해석하여 여러 과정을 거쳐 콘텐츠를 보여주는 과정을 브라우저의 렌더링 과정이라 한다.
크게 Parsing => Calculate Style  => Layout => Paint => Composite & Render 과정으로 이루어진다.

## Parsing(파싱)
파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 작업을 의미한다. HTML파일을 해석하여 리소스 구성에 따라 DOM 트리 및 CSSOM 트리를 구성한다.
파싱 결과는 부모-자식 관계를 가지는 노트 트리 구조이다.
### DOM 트리 구성
렌더링 엔진에서 HTML데이터를 수신하고 해석, 파싱 과정을 거쳐 DOM을 생성한 후, 각 DOM 객체를 트리 데이터 구조로 연결해 DOM트리를 구성한다.
### CSSOM 트리 구성
파싱 과정 중 스타일시트 파일을 만나면 CSS를 해석하며 CSSOM 트리를 구성한다.

## Calculate Style(스타일 계산)
스타일 계산 단계에서는 파싱 단계에서 생성된 DOM, CSSOM 트리를 가지고 스타일 매칭 후 렌더 트리를 구성한다. 

## Layout(레이아웃)
레이아웃 단계에서는 노드의 정확한 위치와 크기를 계산한다. 루트 노드 부터 노드를 순회하면서 계산하고, 레이아웃의 결과로 각 노드의 정확한 위치와 크기를 픽셀값으로 렌더 트리에 반영한다.
CSS에서 %값으로 크기를 지정하면 레이아웃 단계를 거쳐 측정 가능한 픽셀 단위로 변환된다.

## Paint(페인트)
레이아웃 단계에서 계산된 값을 이용해 렌더 트리의 각 노드를 화면상의 실제 픽셀로 변환한다.
이때 위치, 크기, 모양과 관계없는 CSS 속성(색상, 투명도 등)을 적용하여 색을 칠하는 순서를 판단한다. transform 속성등을 기준으로 픽셀로 변환된 결과들은 포토샵의 레이어 처럼 생성되어 개별 레이어로 관리된다. 

## Composite & Render(합성 & 렌더)
페인트 단계에서 생성된 레이어를 합성하여 스크린을 업데이트하며 화면에서 웹 페이지를 볼 수 있다.

# 브라우저의 동시성
---
자바스크립트는 싱글 스레드 기반의 언어다. 싱글 스레드로 동작하기 때문에 [[Async, Promise#^c6e5a8|블로킹]]이 발생할 수 밖에 없고 자바스크립트 엔진 만으로는 브라우저의 동시성(Concurrency)을 지원할 수 없다.
이를 위해 자바스크립트 뿐만 아니라 브라우저의 여러 스레드와 프로세스를 통해서 동시성을 지원할 수 있다.

## Event Loop(이벤트 루프)
브라우저의 동시성을 위해 자바스크립트 엔진(콜 스택, Heap) 외에 이벤트 루프, Task Queue(테스크 큐), Web API등을 이용하여 브라우저가 지원 하여 처리한다.

- Event Loop - 이벤트 루프는 콜 스택과 테스크 큐 사이에 위치 한다. 
  콜 스택이 비어 있는지 감시하며 비어 있을 경우 테스크 큐에 있는 작업을 콜 스택으로 전달하는 역할을 한다.
- Web API - setTimeout, DOM, Fetch, HTTP 등 브라우저와 상호 작용할 수 있도록 하는 API 이다.
- Task Queue - Web API 콜백 또는 이벤트 핸들러를 추후에 실행될 수 있도록 저장하는 공간이다.

https://www.lydiahallie.com/blog/event-loop
### 이벤트 루프 처리 과정
```js
setTimeout(() => {
  console.log('first');
}, 0);

console.log('second');
```
먼저 setTimeout**함수가 호출**되어 **실행 컨텍스트를 생성**하고 **콜 스택에 쌓인다**.
콜 스택에 담기기 때문에  해당 **함수가 실행**되고 **콜백 함수와 타이머 정보**가 **Web API로** 넘긴다. **해당 컨텍스트는 종료되고** **콜 스택에서 팝** 된다.
콜 스택에서 실행이 종료되어 다음 코드로 넘어가고 console.log호출하고 해당 컨텍스트를 생성하여 콜 스택에 담아 실행 한다.
'second'를 출력하고 해당 컨텍스트는 종료되어 콜 스택에서 팝 된다.
그 동안 **Web API에서** 넘겨 받은 해당 콜백 함수는 **지정된 타이머 시간 이후** **테스크 큐로** 해당 콜백 함수를 **넘긴다.**
**이벤트 루프**가 콜 스택과 테스크 큐를 **감시**하며, **콜 스택이 비어 있게 될 때** **테스크 큐의** 콜백 함수를 **콜 스택으로 넘긴다.**
콜 스택에 콜백 함수가 넘어오게 되고 실행되어 'first'를 출력하며 종료된다.

## 마이크로테스크 큐와 프로미스

^c84bba

마이크로테스크 큐는 **프로미스 콜백**을 저장하며 추후에 실행될 수 있도록 저장하는 공간이다. **우선순위**는 **테스크 큐보다 더 높아** 먼저 실행된다.

```js
setTimeout(() => {
	console.log(1)
}, 0);

Promise.resolve()
	.then(() => console.log(2))
	.then(() => console.log(3));
```
setTimeout함수와 Promise가 같이 실행될 때
먼저 setTimeout함수가 호출되어 해당 컨텍스트가 콜 스택에 담겨 실행되고 콜백 함수와 타이머 정보가 Web API에 넘겨진다.
setTimeout함수의 실행 컨텍스트는 종료되고 Promise가 호출된다.
Promise의 실행 컨텍스트가 콜 스택에 담기고 실행된다.
Promise는 실행되어 프로미스 객체를 생성하고 바로 resolve되며 종료된다. 해당 프로미스의 then함수가 다시 실행 컨텍스트를 생성하며 콜 스택에 담기고 실행 되며 해당 콜백 함수를 마이크로테스크 큐에 넘기며 해당 컨텍스트는 종료된다.
이제 테스크 큐와 마이크로테스크 큐에 콜백함수들이 대기하고 이벤트 루프는 콜 스택이 비어있는지 감시한다.
모든 함수가 종료되어 콜 스택이 비어 있으므로 테스크들을 넘기는데 마이크로테스크 큐가 우선순위가 높으므로 해당 테스크들을 모두 콜 스택에 넘긴다.
모두 종료되면 그 뒤에 테스크 큐에 있는 콜백 함수를 넘겨 실행하며 종료된다.

- fetch함수 처리
```js
fetch('https://api...')
  .then((res) => console.log(res));

console.log('end');
```
fetch가 호출 되면 해당 실행 컨텍스트가 생성되고 콜 스택에 담겨 실행된다.
실행 되면 fetch는 Web API로서 프로미스 오브젝트를 생성하고 해당 프로미스 오브젝트는 pending상태와 undefined결과를 가지고 then 콜백함수가 해당 프로미스 오브젝트의 PromiseReaction에 넘겨지며 해당 컨텍스트는 종료되며 콜 스택에서 팝 된다.
fetch가 외부와 통신하는 동안 console.log('end')가 호출되고 실행되어 end'

fetch가 실행되면 프로미스 오브젝트를 생성하고 바로 콜 스택에서 팝되어 종료된다.
해당 프로미스 오브젝트는 pending상태와 undefined의 결과 값을 가지며 해당 객체는 Web API로 넘겨진다.
그리고 then의 콜백 함수는 해당 프로미스 오브젝트의 PromiseReaction에 넘겨진다.
fetch다음의 호출부가 콜 스택에 쌓여 실행되고 종료된다.
이후 통신 결과로 프로미스의 상태가 fullfilled되면 PromiseReactions에 저장한 콜백함수를 마이크로 테스크 큐에 넘긴다.
이벤트 루프는 콜 스택이 비어있는지 확인하고 비어 있다면 해당 콜백 함수를 콜 스택에 넘기고 콜 스택에서 해당 콜백 함수가 실행되며 종료된다.

fetch는 Web API를 통하고, Promise는 Web API를 통하지 않는다.
fetch 실행 컨텍스트는 콜 스택에서 바로 팝되어 사라진다.

## requestAnimationFrame
```js
console.log("start"); 

setTimeout(() => { 
  console.log("macrotask 1"); 
},  0); 

Promise.resolve() 
  .then(() => { 
    console.log("microtask 1"); 
    }) 
  .then(() => { 
    console.log("microtask 2"); 
  }); 

requestAnimationFrame(() => { console.log("requestAnimationFrame callback"); }); 

console.log("end");

```

## fetch
