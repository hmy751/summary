# 이벤트에 응답하기
---

## 이벤트 핸들러 

이벤트 핸들러에 전달되는 함수는 호출이 아니라 전달되어야 한다.
왜냐 하면 JSX의 중괄호 내부는 바로 실행이 되는데 호출로 전달하면 렌더링 중에 즉시 함수를 실행하기 때문이다.
인라인으로 전달할때는 익명 함수로 화살표 함수를 통해서 전달할 수 있다.

## 이벤트 전파

HTML과 똑같이 리액트의 컴포넌트들도 똑같이 이벤트 전파가 발생한다.

## 전파 중지하기

e.stopPropagation 을 이용하여 상위로 전파되는 이벤트를 막을 수 있다.

## event preventDefault

# State: 컴포넌트의 메모리
---
컴포넌트는 반응에 따라 데이터가 변경되며 이를 기억해야 하는데 이때 사용되는 컴포넌트의 메모리 역할을 하는 것이 state라고 한다.

## 지역변수 대신 state

컴포넌트 내부에 지역변수를 통해서 유저 이벤트와 같은 변경에 대해 메모리를 유지하려고 하면 작동하지 않는다. 지역 변수는 렌더링간에 유지되지 않는데 리액트는 지역 변수에 대한 변경사항을 고려하지 않기 때문이다.

컴포넌트를 새 데이터로 업데이트 하려면 렌더링 사이에 데이터가 유지되며 새로운 데이터로 컴포넌트의 렌더링을 촉발해야 한다.
이 두가지를 만족하는게 useState 훅이다.

렌더링사이에 유지되는 데이터 state, 변수를 업데이트 하고 리렌더링을 알리는 setState가 있다.

훅은 조건문, 반복문 등의 내부에서 호출되지 않아야 하며 컴포넌트내 최상위 레벨에서만 호출될 수 있다.

## useState 해부하기

https://react-ko.dev/learn/state-a-components-memory#how-does-react-know-which-state-to-return

## state는 격리되고 프라이빗하다

state는 컴포넌트 인슨턴스에서 지역적으로 존재한다.
즉 state는 같은 컴포넌트에 있더라도 각 컴포넌트가 여러군데에서 렌더링되어도 state는 서로 분리되어 영향을 미치지 않는다. 

state는 일반 변수 처럼 특정 함수 호출이나 코드의 특정위치에 묶이지도 않고 화면상의 특정위치에 지역적으로 있는다고 볼 수 있다.

state는 props와 달리 이를 선언하는 컴포넌트 외에는 완전히 비공개이며 부모 컴포넌트는 이를 변경할 수 없다.

# Render and Commit
---
컴포넌트를 화면에 표시하기 이전에 리액트에서 렌더링을 해야한다.  해당 과정의 단계를 이해하면 코드가 어떻게 실행되는지 이해할 수 있고 렌더링 동작에 관해 이해하는데 도움이된다.

리액트에서 UI를 요청하고 제공하는 3가지 단계이다.
1. 렌더링 트리거
2. 컴포넌트 렌더링
3. DOM에 커밋

## 1. Trigger a render

컴포넌트의 렌더링이 일어나는 이유는 두 가지가 있다.
- 첫 렌더링
- state의 업데이트

### 초기 렌더링
앱을 시작하기 위해서는 첫 렌더링을 트리거시켜야 한다.
대상 DOM노드로 createRoot를 호출한 다음 컴포넌트로 render 메서드를 호출하면 된다.
```jsx
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);
```

### state의 업데이트

첫 렌더링 이후 state를 업데이트하여 추가 렌더링을 트리거 할 수있다. 
state를 업데이트 하면 자동으로 렌더링이 대기열에 추가된다.

## 2. 리액트가 컴포넌트를 렌더링

렌더링을 트리거 하면 리액트는 컴포넌트를 호출하여 화면에 표시할 내용을 파악한다. 즉 렌더링은 리액트에서 컴포넌트를 호출하는 것 이다.

첫 렌더링에서는 루트 컴포넌트를 호출한다.
이후 렌더링에서는 state업데이트에 의헤 렌더링이 발동된 함수 컴포넌트를 호출한다.

렌더링 과정은 재귀적으로 진행된다. 
업데이트된 컴포넌트가 다른 컴포넌트를 반환하면 리액트는 다음으로 해당 컴포넌트를 렌더링하고 해당 컴포넌트도 만약 컴포넌트를 반환하면 반환된 컴포넌트를 다음에 렌더링하는 방식이다.
중첩된 컴포넌트 즉 호출 컴포넌트가 더이상 없을때까지 반복하여 진행된다.

첫 렌더링에는 DOM노드를 생성하고 이후 리렌더링 하는동안에는 이전 렌더링 이후 변경된 속성을 계산하고 다음 단계인 커밋 까지는 아무런 작업을 수행하지 않는다.

렌더링은 항상 순수한 계산이어야 한다.
동일한 입력에는 동일한 출력을 해야한다. 그리고 이전의 state를 변경해서는 안된다.

## 3. 리액트가 DOM에 변경사항을 커밋하기

컴포넌트를 렌더링(호출)한 후에는 리액트는 DOM을 수정한다.

초기 렌더링의 경우 리액트는 appendChild DOM API를 사용해서 생성한 모든 DOM노드를 화면에 표시한다.
리렌더링의 경우 필요한 최소한의 작업(렌더링 하는동안 계산된 것)을 적용하여 DOM이 최신 렌더링 출력과 일치하도록 한다.

리액트는 렌더링 간의 차이가 있는 경우에만 DOM노드를 변경한다.

## 브라우저 페인트

렌더링이 완료되고 리액트가 DOM을 업데이트 한 후 브라우저는 화면을 다시 그리는데 이 단계를 브라우저 렌더링이라고 하지만 페인팅 단계로 분류해서 설명한다.

# 스냅샷으로서의 state
---
state 변수처럼 보일 수 있지만 스냅샷처럼 동작한다. 

## state를 설정하면 렌더링이 트리거 된다.

사용자 이벤트에 의해 인터페이스가 직접 변경되지 않고 state를 설정해야 리렌더링을 요청한다.

- 이벤트를 실행하고
- state를 새로 설정하고 렌더링 큐에 대기 시킨다.
- 새로운 값에 따라 컴포넌트를 다시 렌더링한다.

## 렌더링은 그 시점의 스냅샷을 찍는다.

리액트에서 렌더링은 컴포넌트인 함수를 호출한다는 뜻이다. 해당 함수에서 반환하는 JSX는 그 순간의 UI의 스냅샷처럼 동작한다. prop, 이벤트 핸들러, 로컬 변수는 모두 렌더링 다시의 state를 사용해 계산된다.

UI 스냅샷은 interacitve하다. 여기에는 이벤트 핸들러와 같은 로직이 포함된다. 그러면 리액트는 이 스냅샷과 일치하도록 화면을 업데이트하고 이벤트 핸들러를 연결한다.

컴포넌트가 다시 렌더링할 때
1. 리액트가 함수를 다시 호출하고
2. 함수가 새로운 JSX 스냅샷을 반환한다.
3. 그러면 리액트가 반환된 스냅샷과 일치하도록 화면을 업데이트 한다.

state는 함수 외부에 있는 것처럼 리액트내에 존재하며 함수가 반환된 후 사라지는 일반 변수와 다르다. 
리애그가 컴포넌트를 호출하면 특정 렌더링에 대한 state의 스냅샷을 제공한다. 
컴포넌트는 해당 렌더링의 state값을 사용해 계산된 새로운 props세트와 이벤트 핸들러가 포함된 UI의 스냅샷을 JSX에 반환한다.

state의 설정은 현재 가 아닌 다음 렌더링에 대해서만 변경한다. 첫 번째 렌더링 즉 현재 렌더링된 컴포넌트에서 연속적으로 state를 변경하여 설정해도 다음 렌더링에 영향을 준다.
```jsx
setNumber(number + 1);
setNumber(number + 1);
setNumber(number + 1);
```
이렇게 연속적으로 호출해도 각각의 state설정은 다음 렌더링에 +1d