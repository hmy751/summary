# 이벤트에 응답하기
---

## 이벤트 핸들러 

이벤트 핸들러에 전달되는 함수는 호출이 아니라 전달되어야 한다.
왜냐 하면 JSX의 중괄호 내부는 바로 실행이 되는데 호출로 전달하면 렌더링 중에 즉시 함수를 실행하기 때문이다.
인라인으로 전달할때는 익명 함수로 화살표 함수를 통해서 전달할 수 있다.

## 이벤트 전파

HTML과 똑같이 리액트의 컴포넌트들도 똑같이 이벤트 전파가 발생한다.

## 전파 중지하기

e.stopPropagation 을 이용하여 상위로 전파되는 이벤트를 막을 수 있다.

## event preventDefault

# State: 컴포넌트의 메모리
---
컴포넌트는 반응에 따라 데이터가 변경되며 이를 기억해야 하는데 이때 사용되는 컴포넌트의 메모리 역할을 하는 것이 state라고 한다.

## 지역변수 대신 state

컴포넌트 내부에 지역변수를 통해서 유저 이벤트와 같은 변경에 대해 메모리를 유지하려고 하면 작동하지 않는다. 지역 변수는 렌더링간에 유지되지 않는데 리액트는 지역 변수에 대한 변경사항을 고려하지 않기 때문이다.

컴포넌트를 새 데이터로 업데이트 하려면 렌더링 사이에 데이터가 유지되며 새로운 데이터로 컴포넌트의 렌더링을 촉발해야 한다.
이 두가지를 만족하는게 useState 훅이다.

렌더링사이에 유지되는 데이터 state, 변수를 업데이트 하고 리렌더링을 알리는 setState가 있다.

훅은 조건문, 반복문 등의 내부에서 호출되지 않아야 하며 컴포넌트내 최상위 레벨에서만 호출될 수 있다.

## useState 해부하기

https://react-ko.dev/learn/state-a-components-memory#how-does-react-know-which-state-to-return

## state는 격리되고 프라이빗하다

state는 컴포넌트 인슨턴스에서 지역적으로 존재한다.
즉 state는 같은 컴포넌트에 있더라도 각 컴포넌트가 여러군데에서 렌더링되어도 state는 서로 분리되어 영향을 미치지 않는다. 

state는 일반 변수 처럼 특정 함수 호출이나 코드의 특정위치에 묶이지도 않고 화면상의 특정위치에 지역적으로 있는다고 볼 수 있다.

state는 props와 달리 이를 선언하는 컴포넌트 외에는 완전히 비공개이며 부모 컴포넌트는 이를 변경할 수 없다.

# Render and Commit
---
컴포넌트를 화면에 표시하기 이전에 리액트에서 렌더링을 해야한다.  해당 과정의 단계를 이해하면 코드가 어떻게 실행되는지 이해할 수 있고 렌더링 동작에 관해 이해하는데 도움이된다.

리액트에서 UI를 요청하고 제공하는 3가지 단계이다.
1. 렌더링 트리거
2. 컴포넌트 렌더링
3. DOM에 커밋

## 1. Trigger a render

컴포넌트의 렌더링이 일어나는 이유는 두 가지가 있다.
- 첫 렌더링
- state의 업데이트

### 초기 렌더링
앱을 시작하기 위해서는 첫 렌더링을 트리거시켜야 한다.
대상 DOM노드로 createRoot를 호출한 다음 컴포넌트로 render 메서드를 호출하면 된다.
```jsx
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);
```

### state의 업데이트

첫 렌더링 이후 state를 업데이트하여 추가 렌더링을 트리거 할 수있다. 
state를 업데이트 하면 자동으로 렌더링이 대기열에 추가된다.

## 2. 리액트가 컴포넌트를 렌더링

렌더링을 트리거 하면 리액트는 컴포넌트를 호출하여 화면에 표시할 내용을 파악한다. 즉 렌더링은 리액트에서 컴포넌트를 호출하는 것 이다.

첫 렌더링에서는 루트 컴포넌트를 호출한다.
이후 렌더링에서는 state업데이트에 의헤 렌더링이 발동된 함수 컴포넌트를 호출한다.

렌더링 과정은 재귀적으로 진행된다. 