# 이벤트에 응답하기
---

## 이벤트 핸들러 

이벤트 핸들러에 전달되는 함수는 호출이 아니라 전달되어야 한다.
왜냐 하면 JSX의 중괄호 내부는 바로 실행이 되는데 호출로 전달하면 렌더링 중에 즉시 함수를 실행하기 때문이다.
인라인으로 전달할때는 익명 함수로 화살표 함수를 통해서 전달할 수 있다.

## 이벤트 전파

HTML과 똑같이 리액트의 컴포넌트들도 똑같이 이벤트 전파가 발생한다.

## 전파 중지하기

e.stopPropagation 을 이용하여 상위로 전파되는 이벤트를 막을 수 있다.

## event preventDefault

# State: 컴포넌트의 메모리
---
컴포넌트는 반응에 따라 데이터가 변경되며 이를 기억해야 하는데 이때 사용되는 컴포넌트의 메모리 역할을 하는 것이 state라고 한다.

## 지역변수 대신 state

컴포넌트 내부에 지역변수를 통해서 유저 이벤트와 같은 변경에 대해 메모리를 유지하려고 하면 작동하지 않는다. 지역 변수는 렌더링간에 유지되지 않는데 리액트는 지역 변수에 대한 변경사항을 고려하지 않기 때문이다.

컴포넌트를 새 데이터로 업데이트 하려면 렌더링 사이에 데이터가 유지되며 새로운 데이터로 컴포넌트의 렌더링을 촉발해야 한다.
이 두가지를 만족하는게 useState 훅이다.

렌더링사이에 유지되는 데이터 state, 변수를 업데이트 하고 리렌더링을 알리는 setState가 있다.

훅은 조건문, 반복문 등의 내부에서 호출되지 않아야 하며 컴포넌트내 최상위 레벨에서만 호출될 수 있다.

## useState 해부하기

https://react-ko.dev/learn/state-a-components-memory#how-does-react-know-which-state-to-return

## state는 격리되고 프라이빗하다

state는 컴포넌트 인슨턴스에서 지역적으로 존재한다.
즉 state는 같은 컴포넌트에 있더라도 각 컴포넌트가 여러군데에서 렌더링되어도 state는 서로 분리되어 영향을 미치지 않는다. 

state는 일반 변수 처럼 특정 함수 호출이나 코드의 특정위치에 묶이지도 않고 화면상의 특정위치에 지역적으로 있는다고 볼 수 있다.

state는 props와 달리 이를 선언하는 컴포넌트 외에는 완전히 비공개이며 부모 컴포넌트는 이를 변경할 수 없다.

# Render and Commit
---
컴포넌트를 화면에 표시하기 이전에 리액트에서 렌더링을 해야한다.  해당 과정의 단계를 이해하면 코드가 어떻게 실행되는지 이해할 수 있고 렌더링 동작에 관해 이해하는데 도움이된다.

리액트에서 UI를 요청하고 제공하는 3가지 단계이다.
1. 렌더링 트리거
2. 컴포넌트 렌더링
3. DOM에 커밋

## 1. Trigger a render

컴포넌트의 렌더링이 일어나는 이유는 두 가지가 있다.
- 첫 렌더링
- state의 업데이트

### 초기 렌더링
앱을 시작하기 위해서는 첫 렌더링을 트리거시켜야 한다.
대상 DOM노드로 createRoot를 호출한 다음 컴포넌트로 render 메서드를 호출하면 된다.
```jsx
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);
```

### state의 업데이트

첫 렌더링 이후 state를 업데이트하여 추가 렌더링을 트리거 할 수있다. 
state를 업데이트 하면 자동으로 렌더링이 대기열에 추가된다.

## 2. 리액트가 컴포넌트를 렌더링

렌더링을 트리거 하면 리액트는 컴포넌트를 호출하여 화면에 표시할 내용을 파악한다. 즉 렌더링은 리액트에서 컴포넌트를 호출하는 것 이다.

첫 렌더링에서는 루트 컴포넌트를 호출한다.
이후 렌더링에서는 state업데이트에 의헤 렌더링이 발동된 함수 컴포넌트를 호출한다.

렌더링 과정은 재귀적으로 진행된다. 
업데이트된 컴포넌트가 다른 컴포넌트를 반환하면 리액트는 다음으로 해당 컴포넌트를 렌더링하고 해당 컴포넌트도 만약 컴포넌트를 반환하면 반환된 컴포넌트를 다음에 렌더링하는 방식이다.
중첩된 컴포넌트 즉 호출 컴포넌트가 더이상 없을때까지 반복하여 진행된다.

첫 렌더링에는 DOM노드를 생성하고 이후 리렌더링 하는동안에는 이전 렌더링 이후 변경된 속성을 계산하고 다음 단계인 커밋 까지는 아무런 작업을 수행하지 않는다.

렌더링은 항상 순수한 계산이어야 한다.
동일한 입력에는 동일한 출력을 해야한다. 그리고 이전의 state를 변경해서는 안된다.

## 3. 리액트가 DOM에 변경사항을 커밋하기

컴포넌트를 렌더링(호출)한 후에는 리액트는 DOM을 수정한다.

초기 렌더링의 경우 리액트는 appendChild DOM API를 사용해서 생성한 모든 DOM노드를 화면에 표시한다.
리렌더링의 경우 필요한 최소한의 작업(렌더링 하는동안 계산된 것)을 적용하여 DOM이 최신 렌더링 출력과 일치하도록 한다.

리액트는 렌더링 간의 차이가 있는 경우에만 DOM노드를 변경한다.

## 브라우저 페인트

렌더링이 완료되고 리액트가 DOM을 업데이트 한 후 브라우저는 화면을 다시 그리는데 이 단계를 브라우저 렌더링이라고 하지만 페인팅 단계로 분류해서 설명한다.

# 스냅샷으로서의 state
---
state 변수처럼 보일 수 있지만 스냅샷처럼 동작한다. 

## state를 설정하면 렌더링이 트리거 된다.

사용자 이벤트에 의해 인터페이스가 직접 변경되지 않고 state를 설정해야 리렌더링을 요청한다.

- 이벤트를 실행하고
- state를 새로 설정하고 렌더링 큐에 대기 시킨다.
- 새로운 값에 따라 컴포넌트를 다시 렌더링한다.

## 렌더링은 그 시점의 스냅샷을 찍는다.

리액트에서 렌더링은 컴포넌트인 함수를 호출한다는 뜻이다. 해당 함수에서 반환하는 JSX는 그 순간의 UI의 스냅샷처럼 동작한다. prop, 이벤트 핸들러, 로컬 변수는 모두 렌더링 다시의 state를 사용해 계산된다.

UI 스냅샷은 interacitve하다. 여기에는 이벤트 핸들러와 같은 로직이 포함된다. 그러면 리액트는 이 스냅샷과 일치하도록 화면을 업데이트하고 이벤트 핸들러를 연결한다.

컴포넌트가 다시 렌더링할 때
1. 리액트가 함수를 다시 호출하고
2. 함수가 새로운 JSX 스냅샷을 반환한다.
3. 그러면 리액트가 반환된 스냅샷과 일치하도록 화면을 업데이트 한다.

state는 함수 외부에 있는 것처럼 리액트내에 존재하며 함수가 반환된 후 사라지는 일반 변수와 다르다. 
리애그가 컴포넌트를 호출하면 특정 렌더링에 대한 state의 스냅샷을 제공한다. 
컴포넌트는 해당 렌더링의 state값을 사용해 계산된 새로운 props세트와 이벤트 핸들러가 포함된 UI의 스냅샷을 JSX에 반환한다.

state의 설정은 현재 가 아닌 다음 렌더링에 대해서만 변경한다. 첫 번째 렌더링 즉 현재 렌더링된 컴포넌트에서 연속적으로 state를 변경하여 설정해도 다음 렌더링에 영향을 준다.
```jsx
setNumber(number + 1);
setNumber(number + 1);
setNumber(number + 1);
```

이렇게 연속적으로 호출해도 각각의 state설정은 현재 값 0에서 다음 렌더링에 +1을 한다고 알릴뿐 연속적으로 변경되지 않는다.
```jsx
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

## 시간경과에 따른 state

state 변수의 값은 이벤트 핸들러의 코드가 비동기적이어도 현재 렌더링 내에서 절대 변경되지 않는다. 이 값은 스냅샷으로 고정된 값이며 다음 렌더링에 영향을 준다.
```jsx
setNumber(0 + 5);
setTimeout(() => {
	alert(0);
}, 3000);
```
따라서 화면에는 5로 변경되고 3초후에 0값이 출력된다.

리액트는 하나의 렌더링 이벤트 핸들러 내에서 비동기로 호출하더라도 state값을 고정으로 유지하여 호출한다. 즉 실행되는 동안 state가 변경되었는지 걱정할 필요가 없다.

# 여러 state 업데이트를 큐에 담기
---
state 변수를 설정하면 렌더링이 큐에 들어가게 된다. 그러나 경우에 따라서 다음 렌더링을 큐에 넣기전에 여러 작업을 수행하고 싶을때가 있는데 이때 state업데이트를 배치하는 방법들이 있다.

## state 업데이트 일괄처리

각 렌더링의 state값은 고정되어 있어 연속적으로 실행해도 고정된 state값으로 다음렌더링에 영향을 준다.

리액트는 state 업데이트를 하기전에 이벤트 핸들러의 모든 코드가 실행될 때까지 기다린다. 그래서 리렌더링은 모든 setState 호출이 완료된 이후에 일어난다.
이렇게 해야 너무많은 리렌더링을 트리거하지 않으면서 다수의 state 변수를 업데이트 할 수 있다.
일종의 일괄처리(batching)라고도 볼 수 있다.

그리고 state 업데이트와 달리 클릭과 같은 이벤트에 대해서는 일괄처리하지 않고 개별적으로 처리한다.

## 다음 렌더링 전에 동일한 state 변수를 여러번 업데이트 하기

현재 렌더링에서 다음 렌더링전에 동일한 state 변수를 여러번 업데이트 하고 싶다면 setState에 다음 state를 전달하지 않고, 이전 state를 기반으로 다음 state를 계산하는 함수를 전달해야 한다.
이는 단순히 state의 대체가 아니라 state값으로 무언가를 하라고 지시하는 방법과 같다.
```jsx
setNumber((number) => number + 1);
```

여기서 (number) => number + 1은 업데이터 함수라고 부른다.
이 업데이트 함수를 state setter에 전달하면 리액트는 이벤트 핸들러의 다른 코드가 모두 실행된후에 업데이트 함수가 처리되도록 큐에 넣는다.
다음 렌더링 중에 리액트는 큐를 순회하며 최종 업데이트된 state를 제공한다.

## state를 교체한 후 업데이트 한다면?

업데이터 함수에 state 변수를 교체해서 진행해도 결과는 똑같다.

## 업데이트 후 state를 바꾸면?

```jsx
setNumber(n => n + 1);
setNumber(number + 5);
```
둘 다 큐에 추가된다. 첫번째는 1을 증가시키라고 하여 1을 반환하고 그 다음 큐에서는 0에서 5로 교체하라고 하기때문에 최종 값은 5가된다.

이벤트 핸들러가 완료되면 리렌더링을 실행한다. 리렌더링 동안 큐를 처리한다.

# 객체 state 업데이트
---
state는 객체를 포함해서 어떤 데이터도 저장할수 있다. 하지만 직접 객체를 변이하면 되지 않고 대신 객체 업데이트를 하려면 새 객체를 생성하고 해당 복사본을 사용해서 state를 다시 설정해야 한다.

## mutation?

자바스크립트의 원시형 데이터로 state에서 0에서 5로 변경했다고 가정한다면 0자체는 변경되지 않고 새로운 데이터5로 교체되면서 다른 데이터로 인지해 리렌더링을 발생 시킨다.
왜냐하면 자바스크립트에서는 원시형 값은 불변하기 때문이다.

하지만 객체의 경우 객체 내부의 프로퍼티를 통해서 변경하게 되면 객체 값 자체는 유지되면서 프로퍼티가 변경되게 된다.
이를 mutation이라고 한다.
객체는 기술적으로 이렇게 변이할 수 있지만 불변하는 것처럼 취급해야 한다. 그래서 변이대신 교체해야 된다.

## state를 읽기 전용으로 취급하기

state에 넣는 모든 자바스크립트 객체는 읽기 전용으로 취급해야 한다.
만약 프로퍼티를 통해 변경하면 객체 자체는 변경되지 않았기 때문에 리액트가 변경을 인식하기 못한다.

그래서 읽기 전용으로 취급하여 새로운 객체를 만들고 전달해야 한다.

지역변이(local muation)는 가능하다 예를들어 
```jsx
const nextPosition = {};  

nextPosition.x = e.clientX;  

nextPosition.y = e.clientY;  

setPosition(nextPosition);
```
이렇게 지역적으로 새로운 객체를 만들어서 변경하는 것은 가능하다. 왜냐면 이전 객체가 아니라 지역적으로 생성한 새로운 객체이기 때문이다.

## 스프레드 구문으로 복사하기

변경할 프로퍼티 이외에 프로퍼티는 스프레드 연산자로 간결하게 복사하여 작성할 수 있다.

## 중첩된 객체 업데이트 하기

중첩된 객체도 스프레드 연산자를 통해서 변경이 가능하다.

## Immer로 간결한 업데이트 로직 작성하기

