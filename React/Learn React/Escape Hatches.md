# ref로 값 참조하기
---
컴포넌트가 특정정보를 기억하도록 하면서 해당 정보가 렌더링을 트리거 하지 않도록 하는 경우 ref를 사용할 수 있다.

useRef를 통해서 사용할수 있으며 current를 가지는 객체를 반환한다.
ref는 읽기 쓰기 모두 가능하며 리액트가 추적하지 않는다. 그래서 단방향 데이터 흐름에서 해결할 수 있는 탈출구 역할을 한다.
추적되지 않기 때문에 리렌더링을 발생시키지 않는다.

## 스톱워치 예시

스톱워치를 예시로 하면 스톱워치에서 시작과 끝을 컨트롤하려면  setInterval의 아이디 값이 필요하다 여기서 컴포넌트 리렌더링 간에 값을 유지하면서 렌더링을 트리거 하지 않으려면 setInterval 아이디 값을 ref를 이용해서 구현할 수 있다.

## ref와 state의 차이점

- 리렌더링
ref는 리액트에 변경사항을 알리지 않기 때문에 리렌더링을 발생시키지 않고 state는 변경사항을 알리기 때문에 리렌더링이 발생한다.

- mutable
ref는 렌더링 프로세스 외부에서 current값을 수정하고 업데이트한다.
state는 직접 staet를 변경할 수 없다

- 렌더링중에 값 읽기
ref는 렌더링 사이클과 동기화 되지 않기 때문에 렌더링중에 실시간으로 값이 변경될 수 있어 정확하지 않아 활용되지 않아야 한다.
state는 각 렌더링간에 고정된 스냅샷 처럼 활용돼 렌더링중에 활용해도 문제가 없다.

## ref 내부 작동

https://react-ko.dev/learn/referencing-values-with-refs#how-does-use-ref-work-inside

## ref를 사용해야 하는 경우

ref는 렌더링간의 값을 유지하면서, 리액트 외부로의 상태를 제어하는데 사용하면 좋다.
외부API 처럼 컴포넌트의 형상에는 여향을 주지 않는 브라우저 API 와 통신할 때가 좋은 예다.

- timeout ID
- DOM element
- JSX 과 필요하지 않은 다른 객체 저장

## ref의 좋은 사례

ref는 탈출구로서 브라우저 API와 같이 정말 필요할 때만 사용해야 한다.
렌더링 중에는 절대 ref를 읽고 쓰지 않아야 한다. 왜냐하면 렌더링 중에는 ref를 감지하지 않기 때문에 예측이 되지 않는다.

ref는 자바스크립트 객체 처럼 동작하기 때문에 동기적으로 실행된다.

# Ref로 DOM 조작하기
---
리액트는 렌더링 출력과 일치하도록 DOM을 자동으로 업데이트 하기 때문에 자주 조작할 필요는 없다.
하지만 스크롤이나 크기와 위치를 측정하기 위해서 DOM요소에 접근할 때 ref를 활용할 수 잇다.

## 노드에 대한 ref 가져오기

useRef를 통해서 DOM에 대한 정볼르 가져올 수 있다.
scroll이나 focus와 같이 DOM을 직접 조작하거나 정보를 가져올 때 유용하게 쓰인다.

## ref콜백을 사용하여 refs목록을 관리하는 방법

ref를 모든 항목마다 선언하여 사용할수도 있지만 리스트와 같이 여러개가 있을때 모두 선언하기 어렵다.
이럴때 콜백함수를 전달하여 해결할 수 있다.
콜백함수에 해당 노드를 ref의 Map을 이용해서 할당하여 여러개를 선언하지 않고 해결할 수 잇다.

## 다른 컴포넌트의 DOM노드에 접근하기

빌트인 돔요소가 아닌 실제로 구현한 컴포넌트에 ref를 전달하려고 할 때 에러가 발생한다.
리액트가 일부러 컴포넌트가 다른 컴포넌트의 DOM노드에 접근하는 것을 막으려고 한 의도다. 
만약 다른 컴포넌트의 DOM노드를 수동으로 조작하면 코드가 취약해지기 때문이다.

만약 전달하려면 자식 컴포넌트에 forwadRef를 이용해서 전달할 수 있다.

보통 하위 저수준 컴포넌트에서 이를 많이 활용된다.

만약 하위 컴포넌트가 DOM 변경과 같이 노출을 제한하려면 useImperativeHandle을 활용할 수 있다.

## 리액트가 ref를 첨부할 때

리액트는 렌더링 한후 커밋하는 동안 DOM에 변경사항을 적용한다.

렌더링주에는 ref에 엑세스 하지 않는다.
커밋하는 동안에 ref.current를 설정한다. DOM이 업데이트 되기 전에는 ref.current의 값을 null로 설정 했다가 DOM이 업데이트 된 직후 해당 DOM노드로 다시 설정한다.

## flushSync 동기식 업데이트

state변경은 비동기적으로 실행되므로 동기적으로 ref동작과 같이 하려면 flushSync를 사용해서 state를 변경할 수 있다.

## ref를 이용해서 DOM 조작 잘하기

포커스나 스크롤과 같은 비파괴적인 동작은 ref로 문제가 없다 하지만 수동으로 변경할 때 ref를 사용하게 되면 변경사항과 충돌할 위험이 있다.

그래서 리액트가 관리하는 DOM노드는 직접 변경하지 않는 것을 권장하고 주의가 필요하다.

# Effect와 동기화 하기
---
리액트를 외부 시스템과 동기화 할때 Effect를 사용할 수 있다. Effect는 렌더링 이후에 코드를 실행할 수 있게 한다.

## Effect와 이벤트의 차이점

Effect에 도달하기전에 컴포넌트는 내부의 두가지 작용이 하는데

컴포넌트를 props와 state를 가지고 렌더링 하고, 이벤트 핸들러를 포함한다.
여기서 이벤트 핸들러는 HTTP요청과 같이 외부와 통신할수 있지만 사용자의 명시적인 이벤트가 필요하다.

특정 이벤트가 아닌 서버와 의 연결등 렌더링 자체로 인해 발생하는 사이드 이펙트가 있는데 이를 Effect를 사용하여 처리할 수 있다.

Effect는 화면 어데이트후 커밋이 끝날 때 실행된다.

## Effect가 필요하지 않는 경우

state만을 조정하는 경우 필요하지 않다.

## 디펜던시 설정

ref는 current라는 단일 프로퍼티를 가지는 객체로, 항상 동일한 객체를 반환하기 때문에 디펜던시에 추가되어도 디펜던시의 기능을 하지 않는다.

## Effect 클린업

채팅앱과 같이 컴포넌트가 언마운트 될때 연결해제가 필요한데 이럴경우 클린업을 사용하여 해결할 수 있다.

개발모드에서는 이 클린업을 확인할 수 있도록 마운트가 두번 일어나는데 두번의 마운트로 useEffeect내부가 두번실행된다.
두번의 실행으로 그 사이에 클린업이 필요한 경우나 잘 되고 있는지를 확인할 수 있다.

## 개발 환경에서 두번 처리되는 Effect를 처리하는 방법

개발 환경에서 두번의 effect실행을 잘 해결하려면 클린업을 이용해야 한다.

- 모달과 같은 위젯
- 이벤트 구독
- 애니메이션 트리거
- 데이터 패칭

이렇게 개발 환경에서 위와 같은 예시에서 중복 실행에 대한 오류를 해결하려면 자연스럽게 클린업을 작성해야 한다.

## 페이지 방문 이벤트

Effect로 실행하면 중복실행되어 방문 로그가 정확하지 않을 수 있지만 production모드에서는 상관없다.

만약 앱이 시작될때 한 번만 실행되어야 한다면 
App 상단에서 실행할 수 있다.

```jsx
if (typeof window !== 'undefined') { // Check if we're running in the browser.  

// 실행환경이 브라우저인지 여부 확인  

checkAuthToken();  

loadDataFromLocalStorage();  

}  

function App() {  

// ...  

}
```

## Effect 분리

각 Effect는 분리되어 state의 스냅샷처럼 동작한다.
그리고 이전 Effect를 정리하기전에 클린업이 동작하고 그 다음 Effect가 실행된다.

# Effect가 필요하지 않을 수도 있습니다
---
props나 state가 변경되는 것 과 같이 외부 시스템에 관여하지 않는 경우에는 Effect가 필요하지 않다.

## 캐싱하기

전달 받은 props를 디펜던시로 하여 useEffect내에서 변경하고 이를 state반영하는 방법이 있지만 이는 굉장히 비효율적이다.
우선 첫번째로 state로 설정하는 과정에서 또 다시 리렌더링이 발생한다. 
두 번째로 useEffect에서 실행 하려면 렌더링 커밋을 마치고 실행되기 때문이다.

props 나 state의 값 같은경우는 렌더링 과정에서 필터링하여 바로 계산해도 된다.
위 과정에서는 props를 바로 계산해서 반환해도 된다.
여기에 만약 props에 따라 캐싱 하고 싶다면 useEffect가 아니라 useMemo를 사용해볼 수 있다. useEffect는 외부에 작용과 관련이 있다.

## prop이 변경되면 모든 state 재설정하기

prop이 변경되어도 state가 변경되지 않아 Effect를 사용하려 할 수 있지만 이는 Effect에서도 state를 재설정하므로 리렌더링이 되고 비효율적이다.
대신 key를 통해서 컴포넌트를 구분하여 재설정하게 할 수 있다.

## props가 변경될 때 일부 state 조정하기

useEffect대신 렌더링 중에 직접 state를 조정할수 있다.
```jsx
function List({ items }) {  

const [isReverse, setIsReverse] = useState(false);  

const [selection, setSelection] = useState(null);  

  

// Better: Adjust the state while rendering  
// 더 나음: 렌더링 중에 state 조정  

const [prevItems, setPrevItems] = useState(items);  

if (items !== prevItems) {  

setPrevItems(items);  

setSelection(null);  

}  

// ...  

}
```
위 예시는 렌더링 도중 setSelection이 호출된다. 그럼 리액트에서는 return문과 함께 종료된 직후에 List를 다시 리렌더링 한다.
아직 LIst의 자식들을 렌더링하거나 DOM을 업데이트 하지 않기 때문에 LIst의 자식들은 기존의 selection값에 대한 렌더링을 건너뛴다.
렌더링 도중 컴포넌트를 업데이트 하면 리액트는 반환된 JSX를 버리고 즉시 렌더링을 다시 시도한다.


이것보다 최선은 key로 모든 state를 재설정하거나 렌더링 중에 state를 모두 계산할 수 있는지 확인하는 것이다.

그리고 선택에서 state를 조정할 필요없이 id에 대한 state로 이미 있는 state를 선택하는 방법이 더 권장된다.
```jsx
function List({ items }) {  

const [isReverse, setIsReverse] = useState(false);  

const [selectedId, setSelectedId] = useState(null);  

// ✅ Best: Calculate everything during rendering  

// ✅ 가장 좋음: 렌더링 중에 모든 값을 계산  

const selection = items.find(item => item.id === selectedId) ?? null;  

// ...  

}
```

## 연쇄 계산

Effect를 통해서 연쇄적으로 state를 지정하면 리렌더링이 계속해서 발생한다.

렌더링 중에 가능한 것은 state를 통해 계산하여 변수로 활용하고 state를 조정하는 것이 낫다.

그리고 이벤트 핸들러는 따로 함수로 추출해야 한다.

## 앱 초기화

인증 토큰 처럼 한번만 실행하려고 할때 useEffect 활용보다는 앱 최상단에 실행하는 방법을 생각할 수 있다.

컴포넌트를 import할 때 최상위 레벨의 코드는 렌더링 되지 않더라도 일단 한 번 실행된다.

## state 변경을 부모 컴포넌트에 알리기

변경여부를 알기 위해 부모에서 이벤트를 prop로 내려 이를 Effect로 실행할수 있지만 이보다 단일 명령안에서 처리하는게 낫다.

한 이벤트 핸들러 내에서 이를 알리는 이벤트까지 수행하는 것이다. 이렇게 하면 state는 이벤트 핸들러 내에서 일괄 업데이트 하므로 과정도 한번에 일어나게 된다.
아니면 state끌어올리기를 통해서 부모에서 컨트롤 할 수도 있다.

## 부모에게 데이터 전달하기

Effect를 통해서 데이터를 전달하지 않는게 낫다. 리액트에서는 부모에서 자식으로 데이터가 흐르기 때문에 추적하기 도 힘들다.
차라리 부모에서 데이터를 요청하고 자식에게 넘기는게 낫다.

## 외부 스토어 구독하기

useEffect를 사용할 수도 있지만 그러면 상태를 수동으로 구독해야 한다.
useSyncExternalStore를 통해서 구현하기도 한다.

## 데이터 패칭하기

Effect를 사용해서 패칭 하다보면 응답의 순서도 보장하지 못한다. 이를 경쟁 조건이라고 하는데 이를 해결하기 위해 클린업함수에 플래그를 이용해서 해결할 수 도 있다.
아니면 훅을 통해서 미리 만들어서 구현할 수 도있고 프레임워크를 사용할 수 도 있다.

# 반응형 Effect의 생명주기
---
마운트, 업데이트, 마운트 해제등과 같이 컴포넌트의 생명주기와 Effect는 다르다.
Effect는 동기화를 시작하고 나중에 동기화를 중지하는 두 가지 작업만 할 수 있다.

## Effect의 생명주기

Effect는 컴포넌트의 생명주기와 독립적으로 실행된다. 즉 마운트를 기준으로 동기화가 시작되고 중지되는 것 이 아니다.

채팅 방 연결을 구현한다고 가정하면 prop에 따라 컴포넌트가 변경되고 prop에 따라 동기화를 하고 반드시 클린업함수를 작성하여 이전 이펙트의 동기화를 종료해야 한다.

이렇게 하면 UI와 같이 동기화 되고 언마운트 될때도 클린업을 통해 이전 값의 동기화를 중지할 수 도 있다.

## Effect를 재동기화 하는 방법

Effect를 마운트 언마운트의 콜백함수로 접근하는 것 보다 동기화를 기준으로 시작하는 방법과 중지하는 방법만 집중하면, 필요한 만큼만 Effect를 시작하고 중지할수 있게 된다.

렌더링에서 마운트 언마운트를 생가하지 않는 관점처럼 생각하면 좋다.

## Effect의 재동기화 가능 여부 확인 방법

개발 모드에서 클린업과 재동기화 수행을 확인할 수 있다.

## 재동기화 필요성을 인식하는 방법

디펜던시의 값을 비교하여 확인한다.

## 각각의  Effect는 별도의 동기화 프로세스를 나타낸다.

같은 디펜던시 값이라도 역할이 다르면 Effect를 분리해야 한다.
즉 프로세스를 기준으로 코드를 작성해야 한다.

## Eeffect는 반응형 값에 반응한다.

## 빈 디펜던시의 Effect

## 컴포넌트 본문에서 선언된 모든 변수는 반응형이다.

state나 props에 의해 계산된 변수는 반응형 값으로 판단해야 한다.

## mutation 값은 의존성으로 주입하면 안된다.

location.pathname과 같은 변이 가능한 값은ㅇ 의존성이 될 수 없다.
변이 가능성으로 리액트 흐름에 이상을 줄 수 있다.
대신 useSyncExternalStore를 활용해서 외부 변경 가능한 값을 읽고 구도할 수 있다.

ref.current도 마찬가지다.

## 리액트는 모든 반응형 값을 의존성으로 지정했는지 검토한다.

린터를 통해 의존성을 검사한다.

## 재동기화를 원치않는 경우

url과 같이 재동기화가 되지 않는 값은 컴포넌트 외부에 선언하여 사용하면 린터에서 의존성 배열에 추가를 요구하지 않는다.
아니면 effect내부에 선언할 수 도 있다.

사실 의존성을 선택할 수는 없다 effect 내부의 반응형값으로 추론되는 것은 모두 디펜던시에 추가해야한다.

이럴경우 Effect와의 분리를 다시 고려해보는 것 이 더낫다.

# 이벤트와 Effect 분리하기
---

## 이벤트 핸들러와 구분하기

코드 실행의 이유를 생각하고 이벤트가 필요한가를 따져본다.

## Effect는 동기화를 기준으로

특정 상호작용이 아니라 동기화를 기준으로 하면 Effect를 사용한다.

## 이벤트 핸들러는 내부에  반응형 이 아니다

메시지가 변경되는 것과 보내는것은 별개다 즉 반응형 값이 변경되었다는 이유로 전송이 되어서는 안된다.
그래서 이벤트 핸들러 내부에는 반응형값이 속하지 않는다.

## Effect 내부 로직은 반응형이다.

채팅 연결과 같이 방번호가 달라지면 연결을 다시해야 하는데 Effect는 반응형으로 동작한다.

비 반응형 로직은 분리가 필요하다.

## Effect Event(실험중)

