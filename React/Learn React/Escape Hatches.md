# ref로 값 참조하기
---
컴포넌트가 특정정보를 기억하도록 하면서 해당 정보가 렌더링을 트리거 하지 않도록 하는 경우 ref를 사용할 수 있다.

useRef를 통해서 사용할수 있으며 current를 가지는 객체를 반환한다.
ref는 읽기 쓰기 모두 가능하며 리액트가 추적하지 않는다. 그래서 단방향 데이터 흐름에서 해결할 수 있는 탈출구 역할을 한다.
추적되지 않기 때문에 리렌더링을 발생시키지 않는다.

## 스톱워치 예시

스톱워치를 예시로 하면 스톱워치에서 시작과 끝을 컨트롤하려면  setInterval의 아이디 값이 필요하다 여기서 컴포넌트 리렌더링 간에 값을 유지하면서 렌더링을 트리거 하지 않으려면 setInterval 아이디 값을 ref를 이용해서 구현할 수 있다.

## ref와 state의 차이점

- 리렌더링
ref는 리액트에 변경사항을 알리지 않기 때문에 리렌더링을 발생시키지 않고 state는 변경사항을 알리기 때문에 리렌더링이 발생한다.

- mutable
ref는 렌더링 프로세스 외부에서 current값을 수정하고 업데이트한다.
state는 직접 staet를 변경할 수 없다

- 렌더링중에 값 읽기
ref는 렌더링 사이클과 동기화 되지 않기 때문에 렌더링중에 실시간으로 값이 변경될 수 있어 정확하지 않아 활용되지 않아야 한다.
state는 각 렌더링간에 고정된 스냅샷 처럼 활용돼 렌더링중에 활용해도 문제가 없다.

## ref 내부 작동

https://react-ko.dev/learn/referencing-values-with-refs#how-does-use-ref-work-inside

## ref를 사용해야 하는 경우

ref는 렌더링간의 값을 유지하면서, 리액트 외부로의 상태를 제어하는데 사용하면 좋다.
외부API 처럼 컴포넌트의 형상에는 여향을 주지 않는 브라우저 API 와 통신할 때가 좋은 예다.

- timeout ID
- DOM element
- JSX 과 필요하지 않은 다른 객체 저장

## ref의 좋은 사례

ref는 탈출구로서 브라우저 API와 같이 정말 필요할 때만 사용해야 한다.
렌더링 중에는 절대 ref를 읽고 쓰지 않아야 한다. 왜냐하면 렌더링 중에는 ref를 감지하지 않기 때문에 예측이 되지 않는다.

ref는 자바스크립트 객체 처럼 동작하기 때문에 동기적으로 실행된다.

# Ref로 DOM 조작하기
---
리액트는 렌더링 출력과 일치하도록 DOM을 자동으로 업데이트 하기 때문에 자주 조작할 필요는 없다.
하지만 스크롤이나 크기와 위치를 측정하기 위해서 DOM요소에 접근할 때 ref를 활용할 수 잇다.

## 노드에 대한 ref 가져오기

useRef를 통해서 DOM에 대한 정볼르 가져올 수 있다.
scroll이나 focus와 같이 DOM을 직접 조작하거나 정보를 가져올 때 유용하게 쓰인다.

## ref콜백을 사용하여 refs목록을 관리하는 방법

ref를 모든 항목마다 선언하여 사용할수도 있지만 리스트와 같이 여러개가 있을때 모두 선언하기 어렵다.
이럴때 콜백함수를 전달하여 해결할 수 있다.
콜백함수에 해당 노드를 ref의 Map을 이용해서 할당하여 여러개를 선언하지 않고 해결할 수 잇다.

## 다른 컴포넌트의 DOM노드에 접근하기

빌트인 돔요소가 아닌 실제로 구현한 컴포넌트에 ref를 전달하려고 할 때 에러가 발생한다.
리액트가 일부러 컴포넌트가 다른 컴포넌트의 DOM노드에 접근하는 것을 막으려고 한 의도다. 
만약 다른 컴포넌트의 DOM노드를 수동으로 조작하면 코드가 취약해지기 때문이다.

만약 전달하려면 자식 컴포넌트에 forwadRef를 이용해서 전달할 수 있다.

보통 하위 저수준 컴포넌트에서 이를 많이 활용된다.

만약 하위 컴포넌트가 DOM 변경과 같이 노출을 제한하려면 useImperativeHandle을 활용할 수 있다.

## 리액트가 ref를 첨부할 때

리액트는 렌더링 한후 커밋하는 동안 DOM에 변경사항을 적용한다.

렌더링주에는 ref에 엑세스 하지 않는다.
커밋하는 동안에 ref.current를 설정한다. DOM이 업데이트 되기 전에는 ref.current의 값을 null로 설정 했다가 DOM이 업데이트 된 직후 해당 DOM노드로 다시 설정한다.

## flushSync 동기식 업데이트

state변경은 비동기적으로 실행되므로 동기적으로 ref동작과 같이 하려면 flushSync를 사용해서 state를 변경할 수 있다.

## ref를 이용해서 DOM 조작 잘하기

포커스나 스크롤과 같은 비파괴적인 동작은 ref로 문제가 없다 하지만 수동으로 변경할 때 ref를 사용하게 되면 변경사항과 충돌할 위험이 있다.

그래서 리액트가 관리하는 DOM노드는 직접 변경하지 않는 것을 권장하고 주의가 필요하다.

# Effect와 동기화 하기
---
리액트를 외부 시스템과 동기화 할때 Effect를 사용할 수 있다. Effect는 렌더링 이후에 코드를 실행할 수 있게 한다.

## Effect와 이벤트의 차이점

Effect에 도달하기전에 컴포넌트는 내부의 두가지 작용이 하는데

컴포넌트를 props와 state를 가지고 렌더링 하고, 이벤트 핸들러를 포함한다.
여기서 이벤트 핸들러는 HTTP요청과 같이 외부와 통신할수 있지만 사용자의 명시적인 이벤트가 필요하다.

특정 이벤트가 아닌 서버와 의 연결등 렌더링 자체로 인해 발생하는 사이드 이펙트가 있는데 이를 Effect를 사용하여 처리할 수 있다.

Effect는 화면 어데이트후 커밋이 끝날 때 실행된다.

## Effect가 필요하지 않는 경우

state만을 조정하는 경우 필요하지 않다.

## 디펜던시 설정

ref는 current라는 단일 프로퍼티를 가지는 객체로, 항상 동일한 객체를 반환하기 때문에 디펜던시에 추가되어도 디펜던시의 기능을 하지 않는다.

## Effect 클린업

채팅앱과 같이 컴포넌트가 언마운트 될때 연결해제가 필요한데 이럴경우 클린업을 사용하여 해결할 수 있다.

개발모드에서는 이 클린업을 확인할 수 있도록 마운트가 두번 일어나는데 두번의 마운트로 useEffeect내부가 두번실행된다.
두번의 실행으로 그 사이에 클린업이 필요한 경우나 잘 되고 있는지를 확인할 수 있다.

## 개발 환경에서 두번 처리되는 Effect를 처리하는 방법

개발 환경에서 두번의 effect실행을 잘 해결하려면 클린업을 이용해야 한다.

- 모달과 같은 위젯
- 이벤트 구독
- 애니메이션 트리거
- 데이터 패칭

이렇게 개발 환경에서 위와 같은 예시에서 중복 실행에 대한 오류를 해결하려면 자연스럽게 클린업을 작성해야 한다.

## 페이지 방문 이벤트

Effect로 실행하면 중복실행되어 방문 로그가 정확하지 않을 수 있지만 production모드에서는 상관없다.

만약 앱이 시작될때 한 번만 실행되어야 한다면 
App 상단에서 실행할 수 있다.

```jsx
if (typeof window !== 'undefined') { // Check if we're running in the browser.  

// 실행환경이 브라우저인지 여부 확인  

checkAuthToken();  

loadDataFromLocalStorage();  

}  

function App() {  

// ...  

}
```

## Effect 분리

각 Effect는 분리되어 state의 스냅샷처럼 동작한다.
그리고 이전 Effect를 정리하기전에 클린업이 동작하고 그 다음 Effect가 실행된다.

# Effect가 필요하지 않을 수도 있습니다
---
props나 state가 변경되는 것 과 같이 외부 시스템에 관여하지 않는 경우에는 Effect가 필요하지 않다.

## 캐싱하기

전달 받은 props를 디펜던시로 하여 useEffect내에서 변경하고 이를 state반영하는 방법이 있지만 이는 굉장히 비효율적이다.
우선 첫번째로 state로 설정하는 과정에서 또 다시 리렌더링이 발생한다. 
두 번째로 useEffect에서 실행 하려면 렌더링 커밋을 마치고 실행되기 때문이다.

props 나 state의 값 같은경우는 렌더링 과정에서 필터링하여 바로 계산해도 된다.
위 과정에서는 props를 바로 계산해서 반환해도 된다.
여기에 만약 props에 따라 캐싱 하고 싶다면 useEffect가 아니라 useMemo를 사용해볼 수 있다. useEffect는 외부에 작용과 관련이 있다.

## prop이 변경되면 모든 state 재설정하기

